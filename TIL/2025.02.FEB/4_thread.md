# ✏️ 프로세스

**정의** : 컴퓨터에서 연속적으로 실행되는 컴퓨터 프로그램<br>
**동작 과정** : 프로그램을 메모리에 로딩 → CPU에 할당하여 명령어 실행 → 다른 이벤트 대기 → 리소스 해제하며 종료 <br>
**주된 특징**
- 동시성
- 독립적인 자원 → IPC로 자원 공유 가능
- 프로세스 간 영향을 미치지 않음 (충돌 문제 없음)

예) 크롬의 각 탭

<br>

# ✏️ 스레드

**정의** : 프로세스 내 하나의 작업/흐름 단위 <br>
**동작 과정** : 생성 → 실행 → 대기 → 종료 <Br>
**주된 특징**
- 병렬성 (+ 동시성)
- Stack을 제외한 자원의 공유 → 효율적으로 사용
- 스레드 간 영향을 미침
- 공유 메모리 구성 : 힙, 데이터, 코드

예) 유투브의 검색 바, 노래 재생의 동시 처리

<br>

---

<br>

# ✏️ 동시성 / 병렬성

![Image](https://github.com/user-attachments/assets/ee3b832e-3725-4e59-9cf9-89cb3c14b8fc)

### ▶️ 동시성
정의 : 동시에 일어나는 것처럼 보이도록 하는 성질<br>
동시”성”이라 함은 결국 동시에 일어나는 게 아니기 때문에 동시적 성질을 가지도록 하는 것! (그냥 그렇게 이해하기로 함)<br>
💡 심리학에서도 멀티태스킹을 실제 동시에 여러 가지 일을 하는 게 아닌 행위와 뇌의 전환이 빠른 것이라고 정의한다.<br>
동시성을 유지하기 위해 컨텍스트 스위칭(문맥 전환)이 발생<br>

### ▶️ 병렬성
정의 : 실제로 동시에 일어남

<br> 

# ✏️ 컨텍스트 스위칭 / 오버헤드

### ▶️ 오버헤드
정의 : 문맥 전환 시 처리할 때 걸리는 시간<br>
그렇다면 문맥 전환(컨텍스트 스위칭)은 무엇인가?

### ▶️ 문맥 전환(Context Switching)
정의 : 다른 프로세스/스레드로 넘어가 오버헤드가 발생하는 과정<br>
💡 이처럼 프로세스의 동시성 때문에 오버헤드가 발생하고 이는 비용 부담이나 성능 저하를 야기하기 때문에 모든 걸 멀티 스레드로 처리하면 되지 않나? 하는 생각으로 흘렀음 
<br><br>
> 그럼 반대로 생각하면, 프로세스를 최대한 적게 사용하고 스레드를 최대한 많이 사용하면 좋은거네요?
> 
케빈의 강의 자료를 보면 프로세스와 스레드를 비교하여 세 개의 질문이 있다. 나는 그 중 마지막 질문에 공감이 갔다.<br>
성능적으로 동시에 처리하면 아주 좋은 것 아닌가? 하면서..~

하지만 스레드가 마냥 **병렬성**의 특징을 가지는 것은 아니다.<br>
스레드의 병렬성으로 인해 “동기화/동시성 문제”가 발생하기 때문이다.<br><br>

### ▶️ 동기화 문제

- 정의 : 자원의 원자성과 가시성이 보장되지 않는 상황
- 비가시성 : 실제 메모리에 저장된 자원의 값과 스레드에 저장된 값이 다르게 보이는 특징
- 원자성 : 실제 자원에 대한 연산은 한 시점에 한 번만 수행되야 하는 특징<br>
이를 해결하기 위해 스레드의 병렬 처리를 중단하고 한 시점에 하나의 연산만 수행하기 위해 스레드에서도 문맥 전환이 발생한다. → 스레드의 동시성

**여기서 의문!**<br>
스레드에도 똑같이 오버헤드가 발생한다면 프로세스의 문맥전환과 어떤 차이가 있길래 일반적으로 멀티 프로세스보다 멀티 스레드를 지향하는가?<br>
→ 멀티 프로세스의 경우 문맥 전환 시 캐시 초기화가 발생하며 자원을 공유하는 스레드와 달리 IPC를 통해 Heap, Data, Code를 포함하여 모든 자원을 변경해야 하기 때문에 비효율적이며 비용 부담이 더 크다.<br>

이 때문에 위의 케빈 교재의 질문에 더 의문이 생겼다. 어떤 부분에서 틀린 걸까?<br>
1. 스레드의 병렬 처리의 경우, 스레드끼리 충돌한다면 스레드끼리는 서로 영향을 미치기 때문에 프로세스 자체가 중단될 수 있다. 반면 프로세스는 서로 충돌이 일어나지 않기 때문에 하나의 프로세스가 중단되어도 다른 프로세스는 중단되지 않는다.
2. 한 번의 연산을 위해, 즉 원자성을 보장하기 위해 스레드의 오버헤드가 많이 발생할 수 있다. 이는 프로세스 오버 헤드와 마찬 가지로 문맥 전환에 따른 성능 저하, 많은 비용 부담을 야기한다.<br>
→ 프로세스와 스레드의 균형이 적절해야 함

<br>

---

<br>

# ✏️ 동시성 문제 관리

스레드의 동시성 문제는 `synchronized(lock)`, `atomic`, `volatile` 세 가지 방법으로 해결할 수 있다.
### ▶️ synchronized 키워드 활용
    
    ```java
    public synchronized void increment() {
    	value++;
    }
    ```
    
  두 개의 스레드를 동시에 처리하던 중 하나의 스레드에는 lock을 거는 방식<br>    
    함수 선언의 접근 제어자와 반환형 사이에 넣어주기만 하면 된다.<br>
    오버헤드를 발생시키기 때문에 성능이 좋지는 않다.
    
### ▶️ atomic 클래스
    
    ```java
    import java.util.concurrent.atomic.AtomicInteger;
    
    public class Counter {
        private AtomicInteger value = new AtomicInteger(0);
    
        public synchronized void increment() {
            value.incrementAndGet();
        }
    
        public int getValue() {
            return value.get();
        }
    }
    ```
  자료형별로 존재하는 atomic에 있는 클래스의 객체를 호출하고 함수를 활용하여 비원자성 문제를 해결하는 방식<br>    
    lock을 걸지 않기 때문에 병렬성이 유지되며 오버헤드 발생이 가장 적어 비용 부담도 적고 성능이 좋다.<br>
    https://saltyzun.tistory.com/37<br>    
    대충 atomic 안에서 메모리 값과 새로운 값을 비교하며 참/거짓을 반환하는 로직이 있다고 한다.
    
### ▶️ volatile
    `volatile int value = 0;` 
  
  https://oneny.tistory.com/41<br>
    https://velog.io/@bombab/volatile%EC%9D%98<br>
    atomic과 마찬가지로 lock을 걸지 않는 방식이며 메인 메모리에서 변수를 읽고 업데이트하기 때문에 가시성이 보장되지만 연산이 있을 경우 원자성을 절대적으로 보장하지는 않아 결국 동시성 문제 해결 못 함
    
❗️ 추가로 알아보면 좋을 단어 : mutex, semaphore

<br>

---

<br>

# 👀 느낀점

아침에 시작하고 얼마 안 돼서 케빈이 `System.out.Println` 이 대표적인 오버로딩의 예시라고 알려줬는데 가장 가까이에서 쉽게 접하는 것들을 내가 배운 개념과 접목시키지 못할 때마다 띠용하긴 한다. 오늘도 한 충격 먹고 하루 시작. <br>
어제, 아니 오늘 밤을 새서 점심 이후에 진짜 죽는 줄 알았다. 점심 안 먹고 차라리 1시간이라도 잠을 자자 싶어서 잤는데 1시에 일어나긴 했는데 진짜 아무것도 안 들렸음. 그래서 한 3시쯤에 커피 마시니까 갑자기 또 살아나서 그때부터 강의 듣기 시작했다. <br>
심지어 아예 모르는 개념이어서 오늘 강의를 더 어렵다 느꼈다. 근데 당연함. 학교에서 운영체제 수업할 때 우리 분반 교수님이 안식년이셨다가 개강 당일에 불려와서 한 학기 내내 거의 수업 안 하다시피 하고 시험도 과제로 대체해서 출석 안 해도 비쁠 나왔음. 2주차까지 학교 욕 하다가 드랍한 사람이 절반인데 폐강 안 되고 나는 안 버리고 듣다 보니 얻은 건 없지만 가성비 댕꿀 수업이었음 ㄴㅇㅅ<br>
암튼 근데 오늘 수업도 거의 안 들리고 3시부터 케빈 교재 보면서 혼자 독학함. 그래서 오늘 쓴 배움일기를 잘 작성했는지는 모르겠지만 오히려 좋아. 이게 바로 나만의 언어? 아 사실 걍 케빈의 언어임. 암튼 보이드가 저번주 나만의 기술 블로그로 등극했는데 오늘은 케빈이 등극함. 축하드려요. <br>
오늘 하루가 너무 빡셌지만 용케 TIL까지 작성한 나 아주 칭찬해~ 근데 막상 어제 거를 하나도 모름 내일 해야지~ 그리고 생각보다 독학하면서 본 개념 꽤 재밌음. 시소프 열심히 듣고 재밌어했는데 운체 버렸으니 어쩌면 재밌는 게 당연할지도?<br>
오늘 한 시간 잤는데 밤 되니까 갑자기 또 생생한 게 어이가 없지만 오늘은 12시 땡 잘 거임. 하루 끝~<br>
그리고 아침 9시에 과제 딱 끝내서 완료 처리 했는데 케빈이 바로 `검토 중` 해줘서 아주 빠른 피드백 받음 후후<br>
여전히 할 게 산더미네요~<br>

<img width="369" alt="Image" src="https://github.com/user-attachments/assets/229d9df2-a1d7-4408-b5ee-b9d9e50ec87c" /><br>
아 근데 이거 버근가... ㅋㅋㅋㅋㅋ...
근데 밤 새서 이 정도 한 거 맞긴 한데...
갑자기 rize 유료 결제하라 해서 좀 우울해짐...
