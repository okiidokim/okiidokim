## ✏️ 자바스크립트 객체

- 정의 : key:value 쌍으로 하여 속성과 기능을 묶은 “독립적인” 코드 단위
- 목적 : 데이터와 데이터 관련 연산을 함께 “관리”하기 위해
- 사용 방법
    - 객체 리터럴
        - “리터럴” : 소스코드의 고정된 값을 나타내는 표기법
        
        ```jsx
        const objectName = {
        	name : "daisy",
        	age : 24
        	addAge : function(param) {
        		//구현
        	}
        }
        //접근
        objectName.name
        objectName.addAge(param);
        ```
        
        - es6로 축약형 함수 정의
            
            ```jsx
            addAge() {
            //구현
            }
            ```
            
        - 동적 함수 추가
            
            ```jsx
            objectName.greet = function() {
            	//구현
            }
            ```
            
    - 생성자 new
        
        ```jsx
        function Object(name, age) {
        	this.name = name;
        	this.age = age;
        	this.greet = function() {
        		//구현
        	}
        }
        
        const daisy = new Object("daisy", 24);
        daisy.greet();
        ```
        
    - 클래스
        
        ```jsx
        Class Object {
        	constructor(name, age) {
        		this.name = name;
        		this.age = age;
        	}
        	greet() {
        		//구현
        	}
        }
        ```
        
        - getter, setter
            
            ```jsx
            getName() {
            	return this.name;
            }
            ```
            
        - private 변수
            
            ```jsx
            #name; //선언
            //클래스 내부에서만 사용, 변경 가능하며 외부에서 직접적인 변경은 불가능
            ```
            
<br><br>

## ✏️ 네임 스페이스

- 정의 : 클래스, 변수, 함수명과 같이 동일한 식별자의 선언으로 인한 충돌을 막기 위해 그룹화하는 방법
- 목적
    1. 동일한 식별자의 충돌 방지
    2. 코드 구조화 → 특징적인 것끼리 묶어 유지보수성 향상
    3. 유지보수성, 가독성 향상
- 사용 방법
    - 객체로 변수나 함수를 묶어 정의
    
    ```jsx
    const person = {
    	name : "daisy",
    	f : function() {
    	//구현
    	}
    }
    ```
    
    - 외부에서 name, f 라는 이름의 다른 식별자를 사용하더라도 충돌하지 않음
    
    ```jsx
    MyApp = MyApp || {}
    ```
    
    - 객체 명이 겹치는 경우 덮이지 않도록 위와 같이 작성
    - 아니면 export → import하지 말기
- 특징
    - 문법이 있다기보다 방식, 패턴이라고 생각하면 됨
    - 만약 네임스페이스 방식을 사용하지 않으면 먼저 정의한 게 이후에 정의한 것으로 덮어씌워짐

<br><br>

## ✏️ 프로그래밍 패러다임

- 정의 : 프로그램을 구축하는 데 사용되는 기본적인 접근 방식
- 목적 : 코드를 체계적으로 작성하고 효율적으로 재사용하기 위해
- 특징
    - 모듈/객체의 독립성
    - 패러다임이라 쓰고 객체지향이라고 읽는다
- 사용 방법
    - 클래스 → 객체 간 상호작용
    - 함수형 프로그래밍 → 일급 객체 취급
- 종류 → C++ / JAVA / Python

<br><br>

## ✏️ 함수

- 정의 : 재활용 가능하도록 기능적으로 묶은 코드 집합
- 목적 : 여러 군데 필요한 다른 곳에서 하나의 기능으로 묶어 재사용하기 위해
- 사용 방법
    1. 함수 선언문
        
        ```jsx
        function greet(name) {
        //구현
        }
        ```
        
        - greet를 함수로 호이스팅함
        - 호이스팅 : 함수나 변수의 선언을 스코프 최상위로 끌어 올리는 것
        - 스코프 : 함수나 변수의 유효 범위 - 모듈 내부일 수도, 클래스 내부일 수도 선언 위치로 정해짐
            - private, public 접근 제어자 같은 거
        - 호이스팅, this 사용이 필요하면 함수 선언문 사용
    2. 함수 표현식
        
        ```jsx
        const greet = function(name) {
        //구현
        }
        ```
        
        - greet 변수 호이스팅만 하고 function은 익명함수라 호이스팅 안 함
        - var을 사용하면 undefined, let으로 하면 오류
        - this 사용이 필요하면 함수 표현식
    3. 화살표 함수
        
        ```jsx
        const add = (a, b) => { a+b;}
        const person = () => {
        //return문 포함하여 구현
        }
        const person = () => ({
        //return 문 없이 반환 가능
        })
        ```
        
        - 마찬가지로 변수로만 호이스팅 하며 함수로는 호이스팅하지 않음
        - var을 사용하면 undefined, let으로 하면 오류
        - (주의) add 화살표 함수에서 `this.a + this.b` 해 버리면 add 함수 밖의 a, b를 참조하게 됨
        - 화살표 함수 쓸 바엔 함수 표현식 쓰는 게 더 좋은 듯?
- 함수 파라미터/반환 방식
    1. 인자 전달 - 다른 프로그래밍 언어랑 똑같음 (자료형만 없을 뿐)
    2. 객체 전달 - 다른 프로그래밍 언어랑 똑같음 (자료형만 없을 뿐)
    3. 객체 반환 - 구조 분할 할당
        
        ```jsx
        function getPerson() {
        	return person = {
        		name : "daisy",
        		age: 24,
        	}
        }
        const {name, age} = getPerson();
        ```
        
    4. 배열 반환 - 구조 분할 할당
        
        ```jsx
        function getNum() {
        	return [1, 2, 3, 4, 5];
        }
        const [head, ...tail] = num; //[1], [2,3,4,5]
        ```
        
    
    → 구조 분할 할당 안 하면 객체 리터럴로 선언 시 person.name, person.age 이런 식으로 작성해야 함
    
    가독성, 효율성 향상 → 파이썬에서도 본 것 같은디…?
    
<br><br>

## ✏️ 함수형 프로그래밍

### ▶️ 순수 함수

- 정의 : 동일한 입력에 대해 항상 같은 결과를 출력하는 함수
- 목적 : 결정적 동작, 부쇠효과가 없는 동작
    - 부쇠효과
        - 정의 : 외부 데이터에 의해 함수의 결과가 달라 미칠 수 있는 연쇄적인 효과
        
        ```jsx
        const c= 10;
        function sum(a, b) {
        	return a+ b + c;
        }
        ```
        
        - 외부 데이터에 의해 함수의 결과가 바뀔 수 있음
        
        ```jsx
        function sum(a, b) {
        	const c= 10;
        	return a+ b + c;
        } //->이러면 부쇠효과 없음
        ```
        
- 특징
    - 일관된 처리
    - 부쇠효과 없음
    - 명확한 구성요소 (입력, 처리, 출력)

### ▶️ 일급 함수

- 정의 : 변수와 같이 일급 객체/시민으로 취급하는 함수
- 목적
    - 재사용성
    - 고차함수로 사용 가능 : 함수를 인자로 전달 가능
    - 추상화/캡슐화 : 자바 클래스 사용하는 것처럼 하면 됨
    - 유연한 함수 처리 : 이벤트 리스너 같은 거에 용이
- 사용 방법
    - 함수를 변수로 사용
    - 인자로 전달해서 함수 내부에서 호출 가능 - 콜백함수는 일급함수
    - 함수 반환 → 한 함수 내에서 내부 함수를 작성하여 반환 가능
    - 고차 함수로 사용 → 함수 조합 (절차지향 뿌셔)
        
        ```jsx
        function double(multiplier) {
        	return function(num) {
        		return num * multiplier;
        	}
        }
        const doTwo = double(2); //익명함수 반환 - multiplier 파라미터에 들어감
        console.log(doTwo(5)); // 계산 값 반환 - num에 숫자 들어감
        ```
        
        - 유연성, 재사용성의 향상
        - 함수가 이렇게 중첩돼있을 때 변수로 한 번만 선언하면 익명함수를 반환하게 됨을 주의!
            - 익명함수가 값처럼 사용됨을 확실히 알 수 있음
- 특징
    - 순수함수랑 다름 (부쇠효과가 없음 / 함수가 변수처럼 사용)
    - 순수함수는 항상 일급함수
    - 일급함수여도 순수함수로 구현하지 않을 수도 있음 (좋은 함수는 아님)
    - 호이스팅이랑도 다름 (”스코프”최상위 / 최상위 등급의 객체 - 값처럼 사용할 수 있기 때문)

### ▶️ 익명함수

- 정의 : 이름이 없는 함수
- 목적
    - 식별자 충돌 방지 → 한 번만 사용하는 함수의 효율성 증가
    - 가독성 향상 - 특히 콜백함수
    - 클로저 생성 : 스코프 관점에서 외부 변수를 기억하고 접근 가능
- 사용 방법 :
    - 함수 표현식(이름 안 붙인다면)
        - 고급함수 → 함수에 이름을 안 붙이고 변수에 할당해서 인자로 전달하기 좋음
        - 함수 내 정의된 내부 함수의 경우 클로저를 생성하는 특별한 권한(?)을 가져 변수를 기억할 수 있음
    - 화살표 함수
    - 콜백 함수 - 이벤트 리스너

### ▶️ 즉시 실행 함수

- 정의 : 정의되자마자 즉시 실행되는 함수
- 목적
    - 변수의 스코프 제한 - IIFE외부에서 내부의 리소스에 접근 불가능
    - 즉시 실행
    - 캡슐화 - 다른 파일에 모듈처럼 작성해서 코드를 감추거나 파일을 분리해 가독성을 높임
- 사용 방법
    - 전체를 ()로 감싸서 작성
    
    ```jsx
    (
    	function() {
    	//구현
    	}
    )();
    
    <script src="iife.js"></script>
    //이렇게 불러서 호출된 스코프에서 즉시 실행
    ```
    
<br><br>

## ✏️ 구조 분해 할당

- 정의 : 배열이나 객체를 반환할 때 요소를 한 번에 여러 변수에 할당하는 방법
- 목적 : 한 번에 할당하는 효율성, 한 줄에 할당 가능항 간결함, 유지보수성
    
    ```jsx
    const person = {
    name : "daisy",
    age : 24,
    height : 167,
    mbti : "intp"
    }
    const {name, age, ...rest} = person;
    
    //구조 분해 할당 안 쓰면
    const name = person.name;
    const age = person.height;
    ...
    ```
    

## ✏️ 모듈 시스템

### ▶️ 모듈

- 정의 : 재사용 가능한 단위로 나눈 코드 조각 파일
- 목적
    - 복잡한 코드를 나누어 가독성과 유지보수성 향상 → 객체지향!
    - 테스트 용이 → 작은 단위에 대해서만 편하게 테스트할 수 있음

### ▶️ CJS (Common JS)

- 특징
    - 동기적으로 동작
    - 백엔드 개발 시 주로 사용
- 사용 방법
    
    ```jsx
    //cal.js
    function add(a,b) {//구현}
    function sub() {//구현}
    modules.export = {
    add, sub
    }
    
    //main.js
    const cal = require('./cal.js');
    cal.add(1, 2);
    ```
    

### ▶️ ESM

- 특징
    - 최신화된 프론트엔드 웹 개발
- 사용 방법
    
    ```jsx
    //cal.js
    export const add = function(a, b) {}
    export const sub = function() {}
    
    //main.js
    import {add, sub} from './cal.js';
    ```
    
- export default
    
    ```jsx
    //cal.js
    export default const math = {
    //구현
    }
    
    //main.js
    import math from './cal.js';
    ```
    
    - 모듈을 하나로 해서 내보낼 때 사용

<br><br>

## ✏️ 콜백 함수

- 정의 : 함수의 인자로 전달되어 내부에서 실행되는 함수
- 목적 : 동기 함수의 한계, 블로킹의 한계 극복
- 사용 방법
    1. 연산 같은 로직이 두 줄 이상 + 매개변수로 함수를 전달하는 경우
    2. 비동기 상황 + 매개변수로 함수 전달하는 경우

하 근데 콜백함수랑 함수를 인자로 전달하고 함수 실행이 두 개인데 콜백이 아닌 경우가 있나? gpt가 있다고 하는데 자꾸 이상한 말하고 구조상 개똑같은데 다르다고 계속 우겨서 전혀 모르겠음 

포기 욕나옴;; 너무 화남;;; 1시간 반동안 gpt랑 싸우는데 자꾸 같은 말만 보내고 내가 물어보는 거에 반박하는 게 다 이전에 대답한 거고 그거 반박 하면 또 이전전에 보낸 거 대답해서 다른 반박하고 걍 돌아버리겠음

전혀 날 납득시키지 못함 

아;;;;

<br><br>

## ✏️ Promise

- 정의 : 비동기 작업을 수행하기 위한 구조적 방식
- 목적
    - 콜백 지옥 극복
    - 에러 처리 한 번에 가능
- 특징
    - 비동기 + 콜백
    - 해결 시 resolve함수 실행 및 객체의 then()으로 넘어감
    - 실패 시 reject 함수 실행 및 객체의 catch()로 넘어감
- 상태 : 대기(pending), 성공(fulfilled), 실패(rejected)

<br><br>

## ✏️ ES6

- 정의 : 2015년에 업데이트된 js 버전으로 더 나은 문법과 기능이 추가된 표준
- 변경 사항
    1. 클래스 도입
    2. Promise 도입
    3. cosnt, let, 화살표 함수 도입
    4. import/export 도입
