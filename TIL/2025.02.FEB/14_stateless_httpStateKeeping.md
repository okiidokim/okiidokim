## ✏️ stateful

**[정의]** <br>
이전 정보를 기억함 / 이전 상태를 가지고 있음<br>
이전 상태 : 클라이언트의 현재 요청 기준, 이전 요청과 응답에 대한 내용

**[목적]** <br>
사실 상태 유지를 최소화 하는 것이 중요하기 때문에 목적이라고 보기 어렵고 이와 반대되는 stateless를 지향해야 한다.

**[특징]** <br>
- 클라이언트가 이전에 전달한 정보와 응답을 기억하고 있기 때문에 추가 요청에서 클라이언트가 서버에 보내야 하는 정보가 많지 않아도 된다.<br>
    → 하지만 단일 서버일 때만 적용되는 특성<br>
    대규모 서비스에서는 단일 서버를 사용할 수 없음<br>
    단일 서버의 경우 1만 개의 요청을 순차적으로 처리하기 때문에 성능 저하가 발생함
    
- 서버가 바뀔 시 클라이언트가 서버에 전달해야 하는 내용과 절차가 많아짐 → 서버에 의존적으로 동작

**[사용 방법(적용 사례)]** <br>
- 3-way handshaking (TCP 통신) → 네트워크 관점과 연결 관점이 다르기 때문에 적용 사례라고 보기 어려움
- 세션/쿠키 기반 인증<br>  
    세션 정보는 서버의 데이터베이스, 파일 저장소, CPU RAM에 저장되어 상태를 기억하며 요청 및 응답하기 때문에 stateful
    

## ✏️ stateless

**[정의]** <br>
이전 정보를 기억하지 않음 / 이전 상태를 가지고 있지 않음

**[목적]** <br>
서버에 대해 요청을 보냈을 때 여러 서버가 독립적으로 동시에 요청을 처리하기 용이하게 하기 위함<br>

**[특징]** <br>
다른 서버에 동일한 요청을 보내도 일관된 응답이 돌아옴 → HTTP의 특성<br>
여러 서버를 사용함으로써 동시에 여러 요청을 처리하여 응답이 가능<br>
클라이언트에서는 필요한 경우 매번 이전에 전달한 정보를 포함하여 요청해야 하기 때문에 일부 불편한 점이 있음<br>
조회 기능만 있는 경우 매우 효율적<br>
사용자의 개인적인 기능에서는 상태 유지가 필요

**[사용 방법(적용 사례)]**
- UDP<br>
    어떤 데이터가 전송되었는지 기억하지 않고 우선 최대한 전부 보내버리는 방식이라 상태를 기억하지 않음<br>
    → 이것도 마찬가지로 네트워크 관점이라 무상태의 적용사례라고 보기 어려움    
- HTTP : 대표적인 무상태 프로토콜
- REST : 대표적인 무상태 아키텍처
- 토큰 기반 인증

### **[결론] 필요한 경우가 아니면 무상태로!!**

<br>

---

<br>

## ✏️ HTTP가 stateless 특성을 띠는 이유와 웹 애플리케이션이 사용자 상태나 세션을 유지하기 위해 사용하는 방법

### ▶️ HTTP가 stateless 특성을 띠는 이유

http의 connectionless 때문<br>
서버는 클라이언트에게 응답을 보낸 즉시 클라이언트와의 연결을 끊기 때문에 이전 상태를 기억할 수 없음<br>
때문에 규약에 맞춰 요청과 응답을 보내줘야 하며 덕분에 서버 간 일관된 응답을 클라이언트에 보내줄 수 있음

**Redis**<br>
정의 : 현업에서 많이 사용하는 상태 정보를 보관하는 캐시 서버

### ▶️ 세션

**[목적]**<br>
클라이언트에게 개인화된 서비스를 제공

**[정의]**<br>
서버와 클라이언트 사이에 연결을 유지하는 기간/시간

**[특징]**<br>
공개되면 안 되는 정보<br>
일반적으로 서버/인프라 측에 저장되는 정보<br>
세션 정보가 서버에 저장되는 방법 : file-storage, database, cpu<br>
서버에 세션 정보를 가지고 있으며 조회 과정이 필요함<br>
세션 유지 기간동안 상태 유지 - stateful

<br>

**☝️ 쿠키**

**[정의]**<br>
클라이언트 측에 저장되는 사용자 정보 파일

**[특징]**<br>
공개될 수 있는 정보를 담음<br>
서버에서 생성한 jsessionid가 클라이언트에게 전달되면 클라이언트는 쿠키에 jsessionid를 저장<br>
“공간”, 세션 정보를 클라이언트에 작성하여 저장하기 위한 “파일” 개념<br>
jsessionid 뿐만 아니라 토큰도 저장될 수 있음

**[세션 정보를 이용한 응답과 요청의 동작 과정]**<br>
동작 과정 (쿠키가 허용되는 경우/세션 ID가 없을 경우)<br>
1. 클라이언트가 서버에 (로그인) 요청<br>
2. 서버에서 세션 ID 생성 (jsessionid)<br>
3. 서버에서 클라이언트로 세션 ID을 포함한 응답을 반환<br>
4. 클라이언트 측에 세션 쿠키 저장 → 세션ID가 있을 경우 여기서부터 동작<br>
5. 클라이언트가 헤더에 세션 쿠키를 포함하여 서버에 재요청<br>
6. 서버에서 인증 후 응답<br>
    → 코드에서 session.getAttribute(”user”)로 서로 다른 유저의 인증이 가능한 이유
    
쿠키가 허용되지 않을 때는 url에 jsessionid가 인코딩되어 요청된다.

### ▶️ jwt (json web token)<br>
https://velog.io/@chuu1019/%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-JWTJson-Web-Token

**[토큰]** <br>
클라이언트에만 저장 (세션과의 차이점) → 오버헤드가 발생하지 않음

**[동작 과정]** <br>
1. 클라이언트가 서버에 로그인 요청
2. 서버는 클라이언트에 응답으로 토큰을 생성해서 보냄
3. 클라이언트의 브라우저에는 그 토큰이 저장됨
4. 클라이언트는 매번 헤더에 토큰을 포함하여 서버에 요청을 보냄
5. 서버는 토큰을 받아 인증된 사용자인지 토큰을 검증

세션과 달리 서버에서 토큰을 확인만 하면 됨 → 더 좋은 성능

**[jwt 정의]** <br>
인증에 필요한 정보를 비밀키로 서명해 암호화한 json 토큰

**[구조]** <br>
header, payload, signature → stateless하게 인증 가능

**[특징]** <br>
클라이언트의 쿠키에 담아 저장됨<br>
세션 정보를 저장하기 위한 데이터베이스, 파일 저장소와 같은 별도의 서버 측 공간이 필요 없음<br>
단점 : 토큰의 길이가 너무 길면 네트워크 부하가 일어날 수 있음<br>
access token : 유효 기간이 존재<br>
refresh token : access토큰의 유효 시간이 만료되었을 때 refresh 토큰으로 access token을 재발급

## 💬 논의 사항

**[쿠키 없이 세션만으로도 동작 가능한 거 아닌가?]** <br>
쿠키는 세션정보를 클라이언트 측에 저장하는 파일로 클라이언트 측에 저장돼야 하는 정보가 있으면 전부 쿠키에 작성되기 때문에 필요함

**[참고자료]** <br>
https://velog.io/@ghwnd6448/HTTPHTTPS%EC%97%90%EC%84%9C-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%9C%A0%EC%A7%80%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-2.%ED%86%A0%ED%81%B0%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EC%A0%95%EB%A6%AC<br>
https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Stateful-Stateless-%EC%A0%95%EB%A6%AC<br>
https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC#token_%EC%9D%B8%EC%A6%9D<br>

<br>

---

<br>

## 👀 느낀점

챗지피티를 사용하면 100배 높은 효율성의 공부를 자랑할 수 있다.<br>
방금 막 결제했는데 이제 좀 잘 써야겠다.<br>
근데 한 가지 걱정은 지피티 쓰면 공부를 좀 제대로 안 하게 되긴 한다.<br>
하지만 빠르고 효율적인 딥다이브 방법을 좀 더 확실하게 체화할 필요가 있어 보이긴 한다.<br>
지금의 느림을 보완하고 깊이 파는 스탠스를 유지하면서 앞으로 다시 적응해보려 한다.<br>
아 근데 나 노션 마크다운 문법 거의 만렙걸이라 문법 어쩌구는 이지해서 ㄴㅇㅅ

오늘 대면 갔는데 보이드를 봤다.<br>
자꾸 “그냥 지나가는 아저씨라고 생각해 주세요~;!” 말씀하면서 지나다니심 좀 웃기세요<br>
딥다이브 때 8조도 막 딥다이브 하다가 질문 막 던지고 우리 조도 잠깐 와서 20분 정도 해주셨는데 너무 좋았다.<br>
확실히 딥다이브의 감을 잡았다.<br>
근데 보이드 교안 제대로 읽고 강의 제대로 보면 사실 딥다이브 되는 느낌?<br>
거기서 추가로 내가 궁금증 생기는 거 더 파면서 정리하면 되는 것 같다.<br>
왜냐하면 오늘 내가 1번 주제 했는데 보이드가 질문한 거 거의 강의에서 다 말한 내용이었음<br>
그래서 꼼꼼히 보고 TIL 정리할 예정<br>
근데 과제는 언제 하고 강의는 언제 봄? 이번주 과제 자세히 안 보고 목록만 봐도 진짜 양 댕사기로 많음

그리고 아놀디가 정리한 6번 보면서 내가 쿠키에 대해 잘못 설명했음을 알 수 있었음<br>
다른 사람들이 쿠키가 필요하지 않은 것 같은데? 이렇게 질문할 만하게 내가 설명했다.<br>
근데 클라이언트 측에 저장되는 정보라기보단 그 정보를 저장하는 “파일”이라고 조금 더 정확하게 말할 필요가 있었다.<br>
쿠키가 있어야 클라이언트 측에 필요한 거 저장을 하든가 말든가 하지<br>
코드 상에서는 필수로 쓰지 않아도 어차피 자동 생성되는 거라 안 써도 된다, 필요 없다 개념은 아니구나를 아놀디 설명 들으면서 알았다.<br>
그냥 토큰 저장하는 메모장이라고 생각하면 가장 편할 것 같다.

근데 다른 사람 부분 지금 하나도 정리 안 했는데 이건 또 언제 하지<br>
이번주 한 게 없음<br>
댕사고 몰루~ 헤르미온느처럼 하루를 48시간으로 살고 싶네요~ 타임터너 당장 나에게 줘.
<br>
13일 졸업식 이슈로 패스
