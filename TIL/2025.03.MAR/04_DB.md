## ✏️ Database

- 정의
    - 데이터를 관리하는 시스템
- 목적
    - 데이터 무결성을 보장하고 효율적으로 데이터를 관리하기 위함
- 특징 (ACID)
    - ATOMICITY (원자성) : 트랜잭션 내 모든 작업은 한 번에 전부 이루어져야 함 중간에 충돌이 나거나 오류가 발생하면 롤백하여 다시 실행돼야 함
    - CONSISTENCY (일관성 - 정합성) : 트랜잭션 전후 데이터 상태는 일관돼야 함 (유효한 상태)
    - ISOLATION (고립성) = 독립성 : 한 트랙잭션은 다른 트랜잭션에 영향을 미치지 않아야 함
    - DURABILITY (지속성) : 트랜잭션이 성공하면 그 결과는 영구적으로 지속돼야 함
    
    → 트랜잭션 : update, delete, insert라고 쉽게 생각하면 됨
    
    ⇒ 이 네 가지가 합쳐져서 무결성을 보장함
    
    - 일관성 vs 무결성
        - 데이터 제약 조건을 고려하는지 안 하는지에서 가장 큰 차이가 있음
        - 무결성 : 일관성 + 정확성(제약 조건을 지키는 그 정확함)이라 보는 게 맞음
    - 데이터 제약 조건
        1. 개체 무결성 : PK는 NULL일 수 없고 중복될 수 없음
        2. 참조 무결성 : 참조 테이블의 튜플이 존재하기 위해 FK는 유효해야 함
        3. 도메인 무결성 : 보편적으로 각 도메인에는 말이 되는 값이 들어가야 함 (나이는 0살 미만일 수 없음)
        4. 고유성 무결성 : UNIQUE로 정의한 속성(필드)은 중복된 값을 가질 수 없음
        5. NULL 무결성 : NOT NULL로 정의한 속성은 NULL일 수 없음 하지만 NOT NULL을 정의하지 않더라도 NULL값 넣지 말기!
- 종류
    - RDB
    - 비관계형 DB
    - In-memory DB
    - 분산 DB
- 일관성과 무결성의 차이
    - 무결성 : 일관성 + 정확성
        - 일관성을 틀린 데이터여도 그 값을 유지한다는 측면에서 정확한 데이터만 값을 유지하는 무결성과 차이가 있음
- key의 종류
    - PK (Primary Key)
        - 각 테이블의 고유 키
        - 다른 테이블의 참조 키로 들어감
    - 후보키 (Candidate Key)
        - 기본키로 존재할 수 있는 키 (집합)
        - 유일성 + 최소성 만족
        - 보통 UNIQUE 적용되는 속성들
        - 기본키 + 대체키
    - 대체키 (Alternate Key)
        - 후보키 중 PK가 아닌 키 (집합)
    - 외래키 (FK - Foreign Key)
        - 서로 다른 테이블의 관계를 나타내는 키
        - 다른 테이블의 PK
    - 슈퍼키 (Super Key)
        - 유일성을 만족하는 키 집합
        - A, B가 같은 집에 산다면 address는 유일성을 만족하지 않음 → 같은 address
        - {name, address} → 유일하다면 슈퍼키
        - 후보키 포함
    - 복합키 (Composite Key)
        - 단일 필드로 유일성을 보장하지 않을 때
        - 두 개 이상의 필드 집합을 하나의 PK로 보는 키
    - 서브키 (Secondary Key)
        - INDEX
        - 기본키 다음 2등 키 느낌
        - 기본키 이외에 다른 키로 검색할 경우가 많을 때

## ✏️ RDBMS

- 정의
    - 관계형 데이터 베이스를 관리하는 시스템
- 목적
    - 데이터 중복 최소화
    - 무결성 보장
- 특징
    - 테이블 간 관계를 나타냄
    - 기존 엑셀 방식에 비해 나은 성능
- 종류
    - MySQL
    - MariaDB

## ✏️ 정규화 / 역정규화

정규화 : 무결성을 보장하고 데이터 중복을 최소화하기 위해 데이터를 분리 및 구조화하는 과정

1. 제 1정규화 ) 필드에 두 개 이상 들어가는 값 제거
2. 제 2정규화 ) 부분 함수 종속 제거
    - PK로 다른 속성 식별이 불가능하고 해당 속성이 다른 속성으로 식별 가능할 때
    - 완전 다른 묶음 같은 거 두 개 이상일 때 분리
3. 제 3정규화 ) 이행 함수 종속 제거
    - 한 속성이 다른 속성에 종속되고 그 속성은 또 PK에 종속될 때
    - 완전 다른 묶음까지는 아닌데 종속 관계가 타고타고 들어갈 때 분리

역정규화 : 분리된 테이블을 다시 합치거나 데이터 중복을 허용하여 효율성을 높이는 과정

- 정규화를 할수록 테이블은 분리해야되는데 그러면 조회할 때 효율성이 떨어짐
- JOIN이 많아지면 비효율적이고 비용이 많이 듦

→ 실무에서 BCNF, 그 이상으로 정규화하지 않음

### ▶️ 함수 종속성

- 정의 : 한 속성이 다른 속성에 의해 식별 가능함
    - 함수의 정의가 뭔가? - 하나의 X에 하나의 Y가 대응됨 (X에 따른 Y)
    - 마찬가지로 한 속성 X에 대한 다른 속성 Y라고 생각하기
- 목적 : 이상 현상 제거
- 종류
    - 완전 함수 종속성 ) 모든 속성이 PK에 종속됨 → 잘 설계된 RDB
    - 부분 함수 종속성 ) 일부 속성이 PK가 아닌 속성에 종속됨 (제 2정규화 필요)
    - 이행 함수 종속성 ) 일부 속성이 PK가 아닌 속성에 종속되면서 그 속성은 또 다른 속성에 종속됨 (제 3 정규화 필요)
- 이상 현상
    - 정의 : 제대로 정규화되지 않았을 때 발생하는 데이터 중복, 불일치 등의 문제
    - 종류
        1. 삽입 이상 : insert에 필요하지 않은 데이터도 삽입해야 하는 현상
            
            → 테이블을 더 분리해야 됨 (2NF)
            
        2. 수정 이상 : 중복된 데이터를 수정해야 하며 이때 데이터 불일치가 발생하는 현상
            
            → 마찬가지로 테이블을 더 분리해야 함 (3NF)
            
        3. 삭제 이상 : 원하지 않는 데이터까지 삭제되는 현상
            
            → 역시 테이블을 더 분리해야 함 (3NF)
            

## ✏️ JOIN

- 정의 : 두 개 이상의 테이블을 연결하여 데이터를 조회하는 sql 연산 키워드
- 목적 : select문의 중첩(서브 쿼리 방식)은 두 번의 sql문 실행이기 때문에 한 번의 실행으로 더 나은 성능 제공
- 종류와 활용 예시
    1. inner join
        - 교집합
        - 일반적으로 조인이라 하면 이너 조인을 뜻함
        - 활용
            - `ON`
                
                ```sql
                SELECT students.student_id, students.name, lecture.course_id
                FROM students s #s는 별칭
                INNER JOIN lecture l #e는 별칭
                ON s.student_id = l.student_id;
                ```
                
                - ON 뒤의 조건에 해당하는 튜플들 중 lecture 테이블에 있는 것들부터 찾고 그 튜플에 해당하는 students.student_id, students.name, lecture.course_id를 조회
                - join하는 테이블이 중심이 됨
            - `USING`
                
                ```sql
                SELECT student_id, name, course_id
                FROM students
                INNER JOIN lecture 
                USING (student_id);
                ```
                
                - `ON` 을 사용할 때는 각 테이블의 같은 의미를 가진 두 속성이 다른 이름일 수 있음(FK)
                - 이때는 두 속성명이 같아야 함 (마찬가지로 FK)
    2. left join
        - LEFT JOIN 키워드 기준으로 왼쪽에 있는 테이블 전수조사 + 오른쪽 테이블 정보 전부 붙이기
        - 오른쪽 테이블 정보 없으면 NULL처리 → NULL 생기는 문제 발생
        - 합집합인데 기준이 왼쪽 테이블 전수조사
        - 활용
            - `ON`
                
                ```sql
                select students.student_id, students.name, lecture.lecture_id
                from students s
                left join lecture l
                on s.student_id = l.student_id;
                ```
                
            - `USING`
                
                ```sql
                select student_id, name, lecture_id
                from students
                left join lecture
                using (student_id);
                ```
                
    3. right join, full join, cross join, self join 등
- Join 사용 시 주의해야할 점
    - join을 너무 많이 사용할 때 가독성이 떨어질 수 있음
    - 너무 많이 사용하면 비용 부담
    - 너무 많이 사용하면 성능 저하
    - NULL 발생하는 조인들 주의

## ✏️ View

- 정의 : 실제로 데이터를 저장하지 않고 가상의 테이블 구조로 보여주는 sql 객체 키워드
- 목적 : join의 성능 저하를 극복하기 위해 재활용 가능하도록 가상 테이블을 만들기 위해
- 특징
    - 데이터를 물리적으로 저장하지 않음
    - join에 비해 빠른 성능
    - VIEW를 생성한다 해도 바로 사라지는 게 아니라 그걸 재사용할 수 있음 → 효율적
    - 그렇다고 물리적으로 저장하는 건 아님
    - 삭제도 가능 `DROP VIEW`
- 사용 방법
    
    ```sql
    CREATE VIEW student_view AS
    SELECT student_id, name FROM students; 
    ```
    

### ▶️ Materialized View

- 정의 : 일반 view와 달리 물리적으로 저장하는 테이블
- 목적 : 성능 최적화
- 특징
    - 일반 뷰보다 조회 성능이 빠름
    - `REFRESH` 필요 : 데이터 변경 시 키워드를 사용하여 갱신 (일반 뷰는 자동 갱신)
        - 테이블도 마찬가지로 즉시 갱신 (차이점)
    - select(조회)에만 해당 - table과의 차이

## ✏️ Union

- 정의 : select 문 합치는 sql 키워드
- 특징
    - 합칠 때 자동으로 중복 데이터 제거
    - `UNION ALL` - 중복 제거 안 함
- 사용 방법
    
    ```sql
    SELECT student_id, name FROM students_2023
    UNION
    SELECT student_id, name FROM students_2024;
    ```
    
    - 선택하는 속성 수가 같아야 함
    - `DISTICT`(중복 제거)를 자동으로 하기 때문에 성능 저하 가능성 있음
    - `UNION ALL`하면 빠르지만 중복 제거 안 되는 양면성
    - `ORDER BY` 사용 시 합치고 대량 데이터 정렬로 성능 저하 가능성 있음
    
    → join이 더 빠를 수 있음 (pk, index를 사용하니까)
    
    - join과의 차이점
        - 속성 수가 같아야 함
        - pk, index 기반이 아니고 그저 같은 속성 구조를 가져야 함
        - 중복 제거 함
    
    → 테이블 간 관계는 없지만 단순히 테이블을 합칠 때 사용하도록
    

## ✏️ ERD (Entity-Relationship Diagram)

- 정의 : DB를 설계할 때 테이블 간 관계, 속성 등을 시각적으로 나타내기 위한 다이어그램
- 목적 : 담당자(?) 간 원활한 소통, 최적으로 논리적인 DB 설계

### ▶️ 엔티티

- 정의 : DB에서 테이블
- 특징
    - 속성(필드)를 가짐
    - 다른 엔티티와의 관계를 가질 수 있음

### ▶️ 속성

- 정의 : 테이블에서 열의 이름에 해당
- 키, 필드 같은 거
- 속성의 값들은 도메인이 됨

### ▶️ 관계

- 정의 : 엔티티(테이블) 간 연관성
- 종류
    - 1 : 1 ) 말 그대로 하나와 하나만 연결
    - 1 : N ) 말 그대로 하나가 여러 개랑 연결
    - N : M ) 말 그대로 A의 하나가 B의 여러개, 또 B 하나가 A 여러 개 가질 수 있음

## ✏️ 추가 질문

- 관계형 데이터 베이스의 핵심 특징을 설명해주세요
- 복합키 사용하는 상황을 예시로 들어 설명해주세요
    
    
    | name | lecture |
    | --- | --- |
    | daisy | 1 |
    | daisy | 2 |
    | jay | 1 |
    | lucy | 2 |
    | mini | 2 |
    | arnold | 3 |
    
    name으로만 유일성이 보장되지 않음, lecture만으로 유일성이 보장되지 않음
    
    → {name, lecture} 로 유일성이 보장되게 키를 묶어 복합키로 PK 사용
    
- INNER JOIN과 LEFT JOIN의 차이를 예시로 설명해주세요
    
    ```sql
    select student_id, name, lecture_id
    from students
    inner(left) join lecture
    using (students_id);
    ```
    
    - INNER JOIN
        
        
        | student_id | name |
        | --- | --- |
        | 1 | daisy |
        | 2 | jay |
        | 3 | lucy |
        | 4 | mini |
        | 5 | arnold |
        
        | student_id | lecture_id |
        | --- | --- |
        | 1 | 1 |
        | 1 | 2 |
        | 2 | 1 |
        | 2 | 3 |
        | 3 | 3 |
        
        조인 후 (우선 PK 신경 안 쓰고)
        
        | student_id | name | lecture_id |
        | --- | --- | --- |
        | 1 | daisy | 1 |
        | 1 | daisy | 2 |
        | 2 | jay | 1 |
        | 2 | jay | 3 |
        | 3 | lucy | 3 |
      
    - LEFT JOIN  
        
        | student_id | name | lecture_id |
        | --- | --- | --- |
        | 1 | daisy | 1 |
        | 1 | daisy | 2 |
        | 2 | jay | 1 |
        | 2 | jay | 3 |
        | 3 | lucy | 3 |
        | 4 | mini | NULL |
        | 5 | arnold | NULL |

<br>

---

<br>

## 👀 느낀점
DB 재밌다.<br>
VARCHAR랑 CHAR 차이점 한 번 제대로 알아야 하는데...<br>
내일 한 번 이건 더 파보려고 한다.<br>

그리고 디비 공부 이래저래 간단하게 한 거 다 포함해서 한 4번째 정도 공부하는 것 같은데<br>
이제야 좀 이해가 된다.<br>
그리고 정처기랑 학교 수업 때는 BCNF까지 다 했었는데 실무에서 잘 사용하지 않는나는 것도 의외였다.<br>
역정규화는 제대로 기억이 안 났었는데<br>
모든 기술(?)에는 이유가 있다는 점이 흥미를 준다.<br>

작년에 도서 교환 커뮤니티 구현할 때 join 파티여서 가독성이 떨어진다고 생각하긴 했는데<br>
물론 처음 제대로 짜보는 DB에 구조에 조금 문제가 있었지만 <br>
뭔가 문제가 있는 것은 같은데 시간이 없다는 느낌도 있고 해서<br>
제대로 공부하지 못했었다.<br>
확실히 부캠하면서 이해하고 공부하고 넘어가는 부분이 있다는 점이 너무 좋다.<br>
암튼 개인프로젝트 DB는 좀 더 잘 짤 수 있을 것 같은 기분이 든다.<br>

실제로 또 항상 해 보면 느낌이 다르기 때문에 아마 5주차 DB 구조화하고 작성하는 회고도 새로울 것 같다.<br>
오늘은 좀 괜찮은 개념임에도 연휴 이후 바로 시작한 체력 이슈로 개념 점점 뒤로 갈수록 힘이 빠졌는데<br>
내일은 좀 더 개념 정리에 집중하고 과제할 수 있길 바란다!<br>
우선 꼭 DB 데이터타입 분석하기!
