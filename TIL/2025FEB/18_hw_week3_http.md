## ✏️ OSI 7계층 (Open Systems Interconnection)

- 정의 : 컴퓨터 간 네트워크 통신을 7계층으로 과정을 분류한 표준화된 모델
- 목적 : 네트워크 통신의 표준화(통일성)
- 구성 : 물리 계층, 데이터링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층
- 동작 과정(받을 때) : bottom-up
    
    1. 아날로그 신호(서버로부터 받음) → 디지털 신호
    
    2. 디지털 신호 → 프레임(헤더 + 오류검출코드) → MAC 주소 확인 → IP 패킷 추출
    
    3. IP 헤더 목적지 확인 → 세그먼트 추출
    
    4. TCP/UDP 헤더 - 포트 번호 확인 → 오류검출/순서 정렬(TCP) → 데이터(payload) 추출
    
    5. 세션 연결 확인
    
    6. 응용 계층에 알맞는 형태로 데이터 변환 (압축, 암호화, 인코딩)
    
    7. 사용자에게 응답 (DNS 포함)
    
- 동작 과정(줄 때) : top-down - 받을 때와 반대로 동작

<br>

### ▶️ TCP(Transmission Control Protocol)

- 정의 : 신뢰성있는 데이터 전송을 보장하는 연결형 전송 계층 프로토콜
- 목적 : 손실 없고 순서가 보장된 데이터 전송을 위함
- 단위 : 세그먼트
- 특징
    - 데이터의 순서 보장
    - 손실 없는 데이터 보장
    - **흐름제어 - Sliding Window, 혼잡 제어 - Slow Start**
    - 오류 검출, 순서 정렬에 따른 시간 필요 → 느림
    - 오버헤드 발생
- 적용
    - 웹
    - 이메일
    - 파일 전송
- 동작 과정(3-way handshake)
    - 포트 번호 확인 후 데이터 연결(이후 오류 검출, 순서 정렬)을 위해 수행하는 과정인 3-way handshake가 있음
    - 물리적 연결 이상으로 소프트웨어적 연결을 설정(소켓 간 연결)
    1. 클라이언트 → 서버 : SYN - 클라이언트의 연결 준비 완료
    2. 서버 → 클라이언트 : ACK + SYN - 서버의 클라이언트 SYN 확인 및 서버도 준비 완료 요청/응답
    3. 클라이언트 → 서버 : ACK - 서버의 준비 완료 요청(확인)에 대한 클라이언트의 연결하자는 응답

<br>

### ▶️ UDP(User Datagram Protocol)

- 정의 : 빠른 데이터 전송을 위한 비연결형 전송 계층 프로토콜
- 목적 : 실시간에 가까운 신속한 데이터 전송을 위해
- 단위 : 데이터그램
- 특징
    - 오류 검사, 순서 정렬의 과정이 없어 데이터 전송 속도가 빠름
    - 오버헤드가 비교적 적음
    - ACK, 시퀀스 넘버가 없음
    - 데이터의 순서, 손실을 확인하지 않음
- 적용
    - 스트리밍
    - 온라인 게임

<br>

---

<br>

## ✏️ HTTP(Hypertext Transfer Protocol)

- 정의 : 서버와 클라이언트 간 이미지, 비디오 등 텍스트 이상의 자료를 전송하기 위해 사용하는 프로토콜
- 목적 : 일관성 - 컴퓨터 간 하이퍼 텍스트를 전송하기 위한 방법의 표준화
- 특징
    - stateless
    - connectionless
    - 클라이언트와 서버의 독립적 구현 가능
    - 80번 포트

<br>
<br>

## ✏️ HTTPS(Hypertext Transfer Protocol - Secure)

- 정의 : 암호화 알고리즘(TLS/SSL)을 적용하여 서버와 클라이언트 간 안전하게 하이퍼텍스트를 전송하기 위해 사용하는 프로토콜
- 목적 : 중간에 데이터가 가로채질 수도 있는 http의 취약한 보안성 해결
- 특징 (http와 다른 점 측면)
    - 암호화 → 데이터 무결성 : 데이터가 변조되지 않음을 보장
    - 자체 인증 기능이 있음
    - 443포트
    - https + tls/ssl

<br>

### ▶️ TLS / SSL

- 정의 : 데이터를 안전하게 암호화하여 전송하는 프로토콜
- 목적 : http의 보안 취약성 해결
- 특징
    - tls/ssl 인증서에 따른 비용이 필요할 수 있음 → https의 자체 인증 가능하게 함
    - 암호화
    - 데이터 무결성
    - ssl은 현재 사용하지 않음
    - 현재 표준은 tls1.2, tls1.3

<br>

### ▶️ 대칭키 / 비대칭키 암호화 방식

**대칭키**

- 정의 : 1개의 비밀키를 이용하여 데이터를 암호화하고 복호화하는 방식
- 목적 : 데이터를 빠르게 암호화하여 전송하기 위함
- 특징
    - 데이터를 주고 받는 시스템 간 키를 공유해야 함
    - 대칭키가 노출되면 보안에 취약
    - 대량 데이터에 효율적
    - https에서 로그인 인증 이후 세션이 유지되는 기간동안 사용
- 암호화 알고리즘 : AES, DES 등

**비대칭키**

- 정의 : 총 2개의 키, 공개키와 개인키를 이용하여 데이터를 암호화/복호화하는 방식
- 목적 : 대칭키의 키 교환 문제 해결
- 특징
    - 개인키는 서버가 가지고 있으며 노출되지 않음
    - 공개키도 마찬가지로 서버의 것이지만 클라이언트의 최초 요청시 공유됨
    - https에서 로그인 및 인증으로 세션 키 생성 후 응답 시 사용
- 암호화 알고리즘 : RSA, ECC 등

**https에서 동작 과정**

1. 클라이언트의 최초 요청 → 서버는 공개키를 클라이언트에 응답
2. 클라이언트의 로그인/회원가입 요청 - 세션 정보를 공개키로 암호화하여 서버에 전송 → 서버는 개인키로 복호화
3. 이후 클라이언트는 대칭키로 데이터를 암호화하여 요청 → 서버는 대칭키로 데이터를 복호화 → 응답 데이터를 대칭키로 암호화하여 클라이언트에 전송 → 클라이언트는 대칭키로 데이터 복호화

<br>

---

<br>

## ✏️ DNS (Domain Name System)

- 정의 : url, 도메인 이름을 ip주소로 변환하는 시스템
- 목적 : ip주소와 매핑되는 도메인 이름에 대한 저장 공간을 이용하여 서버의 주소를 효율적으로 찾게 하기 위해
- DNS Resolver 구성 : Root DNS 서버, TLD DNS 서버, 권한 네임 서버
- 동작 과정
    1. 사용자가 도메인 이름 입력
    2. `브라우저 DNS 캐시` 확인 → 있으면 13번, 없으면 3번으로
    3. DNS 리졸버는 사용자의 요청을 로컬 DNS 서버로 전송
    4. 브라우저가 로컬 DNS 서버에 매칭되는 ip주소 요청
    5. `로컬 DNS 서버`는 자신의 캐시에서 매칭되는 ip 주소 찾기
    6. ip주소가 없다면 `루트 DNS 서버`로 사용자의 요청을 전송 → 있다면 13번으로
    7. 루트 DNS 서버는 로컬 DNS 서버에 TLD DNS 서버의 주소 전달
    8. 로컬 DNS 서버는 `TLD DNS 서버`에 사용자의 요청을 전송 → 권한 네임 서버의 주소 획득
    9. 로컬 DNS 서버는 `권한 NS 서버`에 사용자의 요청 전송
    10. NS 서버는 로컬 DNS 서버에 실제 ip 주소를 찾아 반환
    11. 로컬 DNS 서버는 자신의 캐시에 ip 주소 저장
    12. 로컬 DNS 서버는 브라우저에 해당 ip주소 반환
    13. 브라우저는 해당 ip주소에 맞는 서버 연결
    14. 웹 페이지 로드
    
    사용자 입력 → 브라우저 캐시 조회 → 로컬 DNS 서버 → 루트 DNS 서버 → TLD DNS 서버 → 권한 NS 서버 → 로컬 DNS 서버 → 브라우저 캐시 → 브라우저 → 사용자
    
<br>

---

<br>

## ✏️ REST API (Representational State Transfer)

- 정의 : REST 아키텍처 스타일을 적용한 API
    - REST : 리소스를 직관적인 규칙을 적용하여 표현하고 서버와 클라이언트 간 데이터를 주고 받는 아키텍처
- 목적 : http를 기반으로 시스템 간 일관적인 통신을 수행하기 위해
- 특징
    - http 메서드 : `POST`, `GET`, `PUT`, `PATCH`, `DELETE`, `OPTIONS`, `HEAD`, `CONNECT`, `TRACE`
    - 클라이언트와 서버의 독립적 개발 가능
    - 직관적이고 단순한 URL(리소스 이름) 구조
- restful
    - http메서드와 동작의 통일성
    - 리소스 이름은 명사
    - /를 기준으로 계층적 구조
    - _, 확장자를 사용하지 않음
    - 소문자 사용

<br>

---

<br>

## ✏️ JWT(JSON Web Token)

- 정의 : json 형식으로 된 정보를 비밀키로 서명해 암호화한 인증서/토큰
- 목적 : stateless하게 서버가 클라이언트를 인증(하여 개인화된 서비스를 제공하기 위해)
- 특징
    - stateless
    - 클라이언트 측에만, 즉 쿠키에 담겨 있음 → 서버 측 부담 감소
    - 요청을 보낼 때마다 헤더에 넣어서 보냄
    - 구성 : header, payload, signature

<br><br>

## ✏️ OAuth

- 정의 : 사용자가 자신의 정보를 타 어플리케이션을 이용하여 인증받을 수 있게 한 프로토콜
- 목적 : 소셜 로그인을 구현하기 위해
- 동작 과정
    1. 사용자의 Kakao Login(소셜 로그인) 버튼 클릭
    2. 클라이언트는 타 앱 인증 서버에 로그인 요청
    3. 타앱 인증 서버에서 로그인 화면을 사용자에 제공
    4. 사용자는 아이디/비번 등 제출
    5. 타 앱 인증 서버는 인증 코드를 사용자에게 반환
    6. 인증 코드는 클라이언트에 전송됨
    7. 클라이언트는 타 앱 인증 서버에 인증 코드를 전송하여 액세스 토큰 요청
    8. 타 앱 인증 서버는 액세스 토큰 발급하여 응답
    9. 클라이언트는 사용자에게 로그인 성공 후 화면 렌더링
    10. 클라이언트는 서버에 액세스 토큰을 포함하여 인증 요청
    11. 서버는 액세스 토큰 검증 후 클라이언트에 응답 전송

→ 근데 이거 항상 백엔드에서 구현하는 것 밖에 못 봤는데 프론트에서도 할 수 있는 건지 몰랐음

근데 또 인터넷 찾아보니 백엔드에서 하는 게 보안상 안전한 것 같기도 하고 디비에 저장하려면 그게 편할 것도 같고…?

<br><br>

## ✏️ 쿠키

- 정의 : 토큰, 세션id와 같은 정보가 클라이언트 측에 저장되는 작은 파일
- 목적 : 요청을 보낼 때 사용하여 서버가 사용자를 구분하게 하기 위함
- 특징
    - 공개될 수 있는 정보
    - jsessionid, 토큰 등의 정보가 저장됨
    - 클라이언트 측에 저장

<br><br>

## ✏️ 세션

- 정의 : 서버와 클라이언트가 연결을 유지하는 시간/기간
- 목적 : http의 stateless 특성으로 인해 개인화된 서비스를 제공하지 못하는 문제를 해결하기 위해
- 특징
    - 세션 유지 기간동안 stateful
    - fileStorage, DB, CPU램 중에 세션 정보가 서버 측에 저장
    - 클라이언트의 요청이 왔을 때 별도의 저장소를 조회해야 해서 오버헤드 발생
    - 일반적으로 공개되면 안 되는 정보
- 쿠키와 동작과정
    1. 클라이언트 : 서버에 로그인 요청
    2. 서버 : jsessionid를 생성하여 클라이언트에 반환
    3. 클라이언트 : 쿠키에 세션 정보(jsessionid)를 저장
    4. 클라이언트 : http 헤더에 쿠키 정보를 포함하여 서버에 데이터 요청 전송
    5. 서버 : 별도의 저장소에 있는 세션 정보와 넘어온 정보를 비교하여 인증
    6. 서버 : 클라이언트에 응답 전송
 
<br>

---

<br>

## 👀 느낀점
와.. 너무 힘들다.<br>
밀린 TIL이 너무 많다.<br>
2/3, 저번주 수, 목, 어제 거 이렇게 지금 네 개 밀려있기도 하고<br>
저번주 금요일 딥다이브도 사실 내 부분만 하고 다른 부분은 못해서 거의 첫 복습 마냥 하는데 한 번에 공부하고 파고들려 하니까 하루 종일 걸렸다.<br>
그리고 분명 restapi 이런 거 보이드 강의랑 겹치는 거 분명 정리했었는데 그새 아예 안 보고 깔끔하게 정리하려니 말 정리하는 게 어려웠다.<br>
그래서 개념 키워드 전부 다 다시 공부하려고 하다 보니 너무 빡셌다.

아니 무슨 게시글 상세 화면 구현하는 것보다 이론 정리하는 게 더 오래 걸리는 게 진짜 억까 같다.<br>
OAuth랑 DNS를 가장 마지막에 정리했는데 진짜 몸이 가만히 있지를 못해서 집중을 잘하지 못했다.<br>
이것들도 저번주 거 TIL부터 다시 하면서 복습해야 할 것 같다.<br>
공부하고 노트에 적고 안 보고 노션에 적긴 했는데 머리에 다 남아있을 것 같진 않다.

사실 개념 정리보다 api 설계를 더 먼저 하고 싶었는데 우선 그걸 다음주로 미루기로 했다.<br>
개념을 더이상 미루다가는 그냥 독학하는 거랑 다를 게 없을 것 같아서...

OSI랑 TCP/UDP 부분 네트워크 전공 수업에서 들었었는데 그냥 뭐 거저 먹듯이 지나갔어서...<br>
CS기초가 이렇게 중요한 지 몰랐지...ㅜㅜ<br>
그때 열심히 해둘 걸... 하는 생각이 든다...<br>
23학년 친구들이 주변에 많은데 우선 컴네랑 운체 열심히 들으라고 말해 두긴 했다...ㅋㅎㅋㅎ<br>
CS기초? 그거 실무에서 어디에 쓰이는데? 이랬던 나의 오만한 생각... 아주 반성한다.<br>
프로젝트 과목만 재밌게 하면서 아 이게 실무지~ 했던 게 이렇게 돌아올 거라고는 하하!<br>
프론트엔드 개념하면서 CS 기초들 병행하면서 복습해야겠다.
