## ✏️ 공유 자원

- 정의 : 여러 사용자나 프로세스가 동시에, 또는 순차적으로 접근하는 시스템의 자원
- 목적
    - 리소스 낭비 방지
    - 협업 가능성 증대
- 사용 방법
    - 자원을 공유하는 메커니즘
- 종류
    - 파일 시스템
    - 네트워킹 프린터
    - 메모리 → 이것이 핵심 ) 구성 : Heap, Data, Code 등
    - 데이터 베이스

<br>

## ✏️ 임계 영역

- 정의 : 공유 자원에 접근하는 프로그램 코드의 일부분
- 목적
    - 경합 조건 유지 : 작업의 경합/순서를 지켜 동시에 실행되지 않게 하여 중복 수정/ 데이터 손실 방지
    - 데이터 무결성 유지 → 원자성과 다를 게 뭔가? / 잘못된 상태로 수정되지 않도록 하는 것
- 공유 자원 - code : 스레드에서 읽기만 가능 / 나머지 : 쓰기/읽기 가능
- 코드 전체가 아닌 임계영역의 코드만이 보호 대상

### 이 윗 부분에서 추가 조사가 필요한 내용
1. 데이터 무결성이란? 데이터가 쉽게 변경되지 않도록 하는 데이터 안전성과 유사<br>
2. 경합 조건이란? → 경합 : 데이터 충돌 <br>
    데이터가 충돌하지 않도록 하는 조건    
3. 데이터 무결성과 원자성의 차이<br>
4. 일관성과 가시성의 차이<br>

<br>

--- 

<br>

## ✏️ 동기화

- 정의 : 여러 작업이 동시에 공유 자원에 접근할 때 데이터 무결성과 충돌 방지, 자원의 일관성을 보장하기 위한 제어 메커니즘
- 동기화를 만족시키기 위한 세 가지 조건
    - Mutual Extension : 상호 배제 - 공유 자원에 대한 배타적 접근 = 하나의 작업이 임계영역에 있다면 나머지 작업은 임계영역에 있을 수 없음
    - Progress : 진행 - 임계영역에 있는 작업이 없고 대기 중인 작업들이 있다면 반드시 하나는 임계영역에 진입해야 한다.
    - Bounded Waiting : 유한한 대기 - (대기 큐를 통해) 작업을 요청한 임계영역은 반드시 실행 기회가 주어져야 함 (무한 대기 금지)
- 사용 방식
    - mutex/락 - 상호 배제 ) 한 번에 하나의 작업만 실행되게 한다 - 화장실
    - 조건 변수 - 진행 ) 알림 - 실행을 위한 특정 조건이 만족됐을 때 신호를 보냄
    - 세마포어 - 상호 배제 + 유한한 대기 ) 대기 큐에 있는 걸 순서대로 실행하여 유한한 대기를 방지하며 동시에 여러 개의 스레드가 실행 가능하게 한다.

### 이 윗 부분에서 추가 조사가 필요한 내용
1. synchronized 키워드와의 연결성
2. 동기/비동기에서의 동기 → 동기화? 생각해 보기
3. 동시성과의 차이점
4. 배타적?

<br>

## ✏️ 락

- 정의 : 한 작업이 공유 자원을 점유하고 있을 때 다른 작업은 점유할 수 없도록 제어하는 동기화 메커니즘
- 락과 원자성의 관계
    - 원자성 : 작업이 전부 실행되거나 아예 실행되지 않거나 (한 번에 실행돼야 하는 한 단위로 봄)
- 동작 방식
    1. 스레드 A의 공유자원 요청
    2. 스레드 A의 공유 자원 점유 - Lock 활성화
    3. 스레드 B의 공유 자원 요청
    4. 스레드 B의 대기
    5. 스레드 A의 작업 완료 - Lock 해제
    6. 스레드 B의 공유자원 점유
- 목적
    - 동기화 > 락 → 동기화와 같은 목적 (일관성)
    - 데이터 무결성 보장
    - 데드락 방지
    - 데이터 경합

### 이 윗 부분에서 추가 조사가 필요한 내용
1. 점유 = is Owner?<br>
→ 락 소유권과 점유는 조금 다른 걔념 같지만 컴파일 시 스레드가 owner가 아니어서 notify()를 수행할 수 없다고 나오는 문구는 점유 여부를 말하는 게 맞는 것 같다.<br>
하지만 그냥 단순히 지금의 내 생각이기 때문에 조사가 필요

<br>

### ▶️ 원자성

- 정의 : 더이상 쪼개질 수 없는 작업 단위의 성질

작업이 쪼개진다면 수정이 중복돼 데이터 일관성/무결성이 보장되지 않음<br>
예를 들어 후위 연산자는 읽기 작업 / 연산 작업이 분리되어 수행되는 작업이므로 원자성이 보장되지 않음<br>
(연산을 쓰기 작업이라 본다면 i++ 는 읽기 + 쓰기 작업)<br>
반면 i += 1은 읽기 작업 없이 쓰기 작업만 있기 때문에 원자성 보장

**volatile의 이해가 한결 쉬워짐**

<br>

### ▶️ 동기화 만족 조건 3가지

**1. 상호배제(Mutual Exclusion)** <br>
한 번에 하나의 작업만 임계 영역에 할당될 수 있다. = 한 번에 하나의 작업만 공유 자원에 접근할 수 있다.

**2. 진행(Progress)** <br>
실행 중인 작업이 없고 모두 대기 중이라면 반드시 하나의 작업은 임계영역으로 가야한다.

**3. 유한한 대기(Bounded Wating)** <br>
공유 자원을 요청한 작업은 반드시 한 번은 실행돼야 한다. (무한 대기 금지)

<br>

**데드락** <Br>
한 스레드가 점유하는 A 스레드가 B를 대기하고 다른 스레드가 점유하는 B 스레드가 A를 대기할 때 데드락 발생
<br>→ 작업 간 실행 순서가 꼬여 무한 대기에 빠지는 현상

**기아 현상** <br>
다른 작업의 실행 시간이 너무 길어 대기 시간이 길어짐에 따라 메모리 할당을 받지 못하는 현상<br>
↔ 데드락(교착 상태)


### 이 윗 부분에서 추가 조사가 필요한 내용
1. Race Condition (경합 조건)
2. -프리 (Lock-Free) / 웨이트-프리 (Wait-Free) 알고리즘

<br>

## ✏️ 락의 종류

### ▶️ 스핀락

- 정의 : 공유 자원의 락이 해제될 때까지 반복적으로 확인하며 점유하는 동기화 메커니즘

- 동작 과정<br>
    스레드A 공유 자원 점유 → 스레드 B 락 해제 확인(반복) → 스레드A 작업 완료 → 스레드 B 공유 자원 점유

- 장점<br>
    문맥 전환에 따른 오버헤드 없음 → 즉시 점유 가능<br>
    실행 시간이 짧은 작업이 많을 때 효율적<br>
    구현이 간단함<br>
    다중 코어, 멀티 코어에 적합
    
- 단점<br>
    단일 cpu에서 사용 불가 - 확인하는 작업이 동시에 불가능<br>
    대기 시간이 긴 작업이 많을 때 cpu 낭비 → 비효율적<br>
    
- 활용 : 커널 내부 구현

<br>

### ▶️ 낙관적 락

- 정의 : 충돌이 발생하지 않는다는 가정 하에 동작하며 충돌 발생 시 롤백하는 락이 없는 메커니즘
  
- 동작 방식
    
    **충돌 발생하지 않은 경우**<br>
    1. 스레드 A가 공유자원 1/3 점유<br>
    2. 스레드 B가 공유자원 1/3 점유<br>
    3. 각자 알아서 작업 완료
    
    **충돌이 발생한 경우**<br>
    1. 스레드 A가 공유자원 0.7 점유<br>
    2. 스레드 B가 공유자원 0.7 점유<bR>
    3. 각자 작업 완료<bR>
    4. 충돌 여부 확인 → O<br>
    5. 스레드 A 롤백 준비 (작업 재실행 준비)<br>
    
    - A가 롤백하는 이유<br>
        먼저 실행됐기 때문에 데이터가 바뀌기 전 자원으로 작업<br>
        우선 순위가 높은 것부터 롤백<br>
        충돌을 먼저 감지한 작업<br>
        → B가 롤백하도록 구현 가능<br>
        
- 장점<br>
    병렬성 증대 → 동시에 작업 가능<br>
    오버헤드 감소 - 동시에 작업하니까<br>
    
- 단점<br>
    충돌 때문에 롤백 시 성능 저하 / 비용 증가<br>
    복잡한 구현

<Br>

### ▶️ 뮤텍스

- 정의 : 서로 다른 작업이 동시에 공유 자원에 접근하지 못하도록 제어하는 동기화 메커니즘<br>
    락 소유권 + 해제권 → 뮤텍스 대기 큐
    
- 동작 방식<br>
    1. 스레드 A의 공유자원 점유 + 락 소유<bR>
    2. B의 공유자원 요청 → 뮤텍스 대기 큐에 notify()<br>
    3. A의 작업 완료 → 락 해제  → 뮤텍스 대기 큐에 notify()<br>
    4. 대기큐 1번(B)의 작업 요청

- 장점<br>
    데이터 무결성 보장<br>
    직관적<br>
    범용성 : 대부분의 OS에서 제공
    
- 단점<br>
    오버헤드<br>
    데드락 발생 가능성 (순서 꼬이면 발생)<br>
    병렬 처리 감소

<br>

### ▶️ 조건 변수(Condition Variable)

- 정의 : 조건을 만족하는 작업에 신호를 보내 실행 시키거나 만족할 때까지 대기시키는 동기화 메커니즘

- 동작 과정<br>
    1. A의 공유 자원 요청 → 점유 → 락 소유<br>
    2. B의 공유 자원 요청 → 조건 불만족으로 조건 대기큐로 wait()<br>
    3. A의 작업 완료 → 조건 변수 대기 큐에 signal()<br>
    4. C의 공유 자원 요청 → 점유 → 락 소유<br>
    5. B의 요청 → 조건은 만족하지만 락 소유권이 없어 뮤텍스 대기 큐로 대기<br>
    6. C의 작업 완료 → 뮤텍스 대기 큐에 notify()<br>
    7. B의 요청 → 점유 → 락 소유<br>
    
- 특징<br>
    - 뮤텍스락과 일반적으로 함께 사용<br>
    - 뮤텍스 대기 큐 → 해제 시 notify()<br>
    - 조건 변수 대기 큐 → 해제 시 signal() / 대기 시 wait()<br>

<br>

### ▶️ Read-Write Lock

- 정의 : “멀티 스레드 환경에서” 읽기와 쓰기를 분리하여 읽기는 동시에 여러 작업의 접근이 가능하게, 쓰기는 한 번에 하나의 작업만 접근할 수 있게 관리하는 동기화 메커니즘

- 특징<br>
    읽기가 많고 쓰기가 적은 환경에 적합
    
- 동작 과정
    1. **읽기 - 읽기 접근**<br>
        읽기 A 요청 → 점유; Readers : A, ReadersCount : 1<br>
        읽기 B 요청 → 점유; Readers : A, B, ReadersCount : 2
        
    2. **읽기 - 쓰기 접근**<br>
        읽기 A 요청 → 점유<br>
        쓰기 B 요청 → Writer 대기에 in<br>
        읽기 A 작업 완료 → 해제 → Writer에 notify()<br>
        쓰기 B 요청(1번이라 가정) → 점유
        
    3. **쓰기 - 읽기 접근**<br>
        2번과 동일 - 쓰기 읽기 역할만 교체
        
    4. **쓰기 - 쓰기 접근**<br>
        2번과 동일 - 읽기만 쓰기로 바뀜
        
- 장점<br>
    읽기 작업의 병렬성<br>
    쓰기 작업의 독립성 → 데이터 무결성 보장
    
- 단점<br>
    데드락 가능성 - 읽기 쓰기 순서 꼬이면 발생 가능성 있음<br>
    Writer 기아 현상<br>
    복잡한 구현

<br>

### ▶️ 세마포어

- 정의 : 유한한 대기 + 상호 배제 → 동시에 접근할 수 있는 작업의 수를 제한하며 나머지 작업은 대기 큐에 대기시켜 데이터 무결성을 보장하는 동기화 메커니즘

<br>

---

<br>

## 추가 질문

### 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.

여러 작업(+ 사용자가)에서 공통으로(동시에 접근하는) 사용하는 시스템의 데이터 및 자원<br>
자원 관리의 효율성 때문에 사용한다.<br>
공용 화장실에서 변기 칸을 사람이 들어올 때마다 만들면 사람이 적을 경우엔 변기 칸 병목 현상이 있을 것이고 계속 변기칸 만드는 데 많은 시간과 비용이 들 것이다.

### 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?
정의 : 공유 자원에 접근하는 프로그램 코드의 일부분<br>
임계영역의 보호함으로써 데이터 무결성을 보장할 수 있다.<br>
중복 수정으로 인한 동시성 문제가 발생할 수 있다.

### 미해결 질문
1. 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.
2. 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.
3. 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.
4. 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.
5. 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.
6. 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.
7. 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.
8. JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?
9. (선택) 분산 락

<bR>

---

<br>

## 👀 느낀점
정의, 장단점, 동작 방식을 정리하는 이 방식이 되게 깔끔하다 느껴졌다.<br>
개인적으로 머리에도 더 잘 남는 느낌이고<br>
근데 낮잠을 자서 아쉽다.<br>
개념 공부하면서 알아 보고 싶은 내용들도 있고 미해결 질문들도 있는데 차차 해나갈 예정이다.<br>
케빈도 오늘 다 하기 많은 양이라고 했다.<br>
물론 내가 잔 것도 있지만... 그래도 내일 크램폴린 강의하는 날이라 시간 날 때 더 정리할 수 있을 것 같다.

뭔가 복습이 밀리는 개념들이 자꾸 생기는데...<br>
초반에 너무 힘을 들였다.<br>
이렇게 달리다가 용두사미가 되는 거 아닌가 했는데<br>
용두는 무슨 사두이다. 이미 뱀의 머리여~<br>
그래도 좀 힘을 빼니까 머리에 들어올 개념도 더 잘 들어오고 그새 적응을 해서 힘을 좀 뺄 수 있는 건지는 모르겠지만<br>
저번주에 너무 고통스러웠던 거에 비하면 괜찮은 듯?<br>

1주차는 긴장해서 그런지 수업 토시 하나도 빠짐 없이 다 귀에 들어오고 집중도 잘 됐는데 너무 힘이 들어가서 지치고 앞으로 잘할 수 있을지 걱정이 됐다.<br>
2주차였던 저번주는 1주차 과제를 월요일에 밤새면서 해서 그런가 일주일 내내 컨디션이 말이 아니었다. 물론 집중도 안 됐고<br>
덕분에 2/3 아키텍처 부분은 하나도 못 한..<br>
그리고 딥다이브 날도 약속을 잡아서 막상 딥다이브를 제대로 못했다.<br>
평일에는 진짜 약속 일절 잡으면 안 되겠구나 싶었다.<br>

이제 3주차에 접어든 오늘... 적당히 힘 들어가고 수업 이후 적당히 집중도 잘된 하루였다.<br>
물론 낮잠을 잔 건 아쉽지만 어제 과제 이슈로 이렇게 됐다.<br>
그래도 저번주는 아예 잠을 못 잤는데 오늘은 3시간이라도 자서 낮잠으로 잘 지나간 듯하다.<br>
내일부터는 잠 루틴부터 돌려놔야겠다.<br>
지금 어느 다짐보다 잠 루틴 돌려놓고 수업에 맞는 생활 리듬부터 찾는 게 제일 중요하겠다는 생각이 들었다.<br>
오늘을 화이팅 이런 다음날 사라지는 말보다 **새벽 2시 반 전에 자고 8시 반 ~ 9시에 기상하는 루틴을 잡자!**는 말로 마무리

### 오늘의 라이즈
<img width="414" alt="스크린샷 2025-02-11 오전 1 31 30" src="https://github.com/user-attachments/assets/4558e3e8-28a6-4fed-9b12-ee2513fb5e9d" />
