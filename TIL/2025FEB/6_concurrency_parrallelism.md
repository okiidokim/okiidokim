## ✏️ 개념 용어

동시성 : 하나의 CPU에서 여러 작업을 빨리 전환함으로써 동시에 실행되는 것처럼 보이게 하는 개념<br>
병렬성 : 여러 CPU, 여러 코어에서 여러 작업을 물리적으로 동시에 실행시키는 개념<br>
스케쥴러 : 여러 작업의 순서를 결정하고 관리하는 OS의 핵심 구성 요소

<br><br>

## ✏️ 스케줄링

**선점형 스케줄링** : 한 작업의 종료를 기다리지 않고 강제로 다른 작업으로 전환하는 방식

- 라운드 로빈 스케줄링 : 모든 작업에 CPU 할당 시간을 부여 및 제한하여 실행시키는 방식<br>
  → 실행 시간이 끝나면 **강제로** 작업을 중단시킴<br>
  1.  실행시간을 너무 길게 설정하면 FCFS의 콘보이 현상처럼 발생<br>
  2. 실행시간을 너무 짧게 설정하면 오버헤드가 많이 발생
 
- 선점 우선순위 : 우선순위 방식에 aging을 적용하여 기아현상을 해결한 방식<br>
  → aging : 시간이 지날수록 우선순위가 낮은 작업의 우선순위를 높여줌

- 다단계 피드백 큐

<br>

**비선점형 스케쥴링** :

- FCFS : 먼저 온 작업부터 실행하는 방식 → 콘보이 현상(convoy effect)발생<br>
    → convoy effect : 실행 시간이 긴 작업으로 인해 이후의 작업의 대기시간이 길어지는 현상
 
- SJF : 짧은 실행 시간을 가진 작업부터 실행하는 방식 → 기아 현상 (starvation) 발생<br>
    → 기아 현상 : 우선순위가 낮은 작업은 계속 밀려 스레드/프로세스를 할당받지 못하는 현상

- HRRN : 응답 비율이 높은 순서부터 실행하는 방식 → 마찬가지로 응답비율이 낮은 작업의 기아 현상

- 우선순위 : 우선순위가 높은 작업부터 실행하는 방식 → 마찬가지로 우선순위가 낮은 작업의 기아 현상

<br>

**종류**
- 장기 : 메모리에 프로그램을 로드
- 중기 : 비활성 상태의 프로그램을 실행해야 하는 다른 프로그램으로 교체 (중단, 새로운 로드)
- 단기 : CPU를 사용할 작업을 선택 및 실행 (필요한 우선순위가 있을 것)

<br>

**스케줄링 정책**

1. CPU 이용률 최대
2. 대기 시간 최소
3. 응답 시간 최소
4. 처리량 최대
5. 총 처리 시간 최소화

<br>

**과정**

1. 작업 대기열 관리 : 작업이 큐 형태로 존재
2. 우선 순위 정하기
3. 자원 분배 : 각 작업에 메모리, CPU 등 필요한 자원을 할당
4. 문맥 전환 : 다음 대기 → 실행 상태
5. 해제 : 실행 완료 → 자원 해제

<br><br>

## ✏️ 컨텍스트 스위칭

동시성을 위해 한 작업에서 다른 작업으로 빠르게 바뀌는 과정 → 오버헤드 발생

**과정**
1. 작업 분할 : 하나의 작업을 더 작은 단위로 분할 (동시적 실행을 위해)
2. 시간 할당 : 작은 단위의 각 작업에 시간 할당 → 하나의 작업이 실행 중일 때 나머지는 대기 상태
3. 문맥 전환 : 시간이 끝나면 현재 작업 상태 저장 후 다음 작업으로 전환

<br><br>

## ✏️ 스레드풀

임의의 스레드 개수만큼 스레드를 생성하여 필요한 작업을 할당하고 해제하는 등 스레드를 재활용하여 관리하는 방식<br>
사용 이유 : 스레드의 재활용, 오버헤드 최소화

장점
- 스레드를 생성하고 삭제하는 데 필요한 문맥 전환 오버헤드를 없애 효율적인 자원 관리
- 스레드 개수를 설정함으로써 무한한 스레드 생성 방지 → 부하 방지

단점
- 스레드풀의 크기가 너무 작을 겨우 단일 스레드와 유사할 것이며 성능 저하
- 작업 간 의존성이 높을 경우 공유 자원의 동시성 문제 발생과 이에 따른 데드락 발생 가능성

<br>

**암달의 법칙**<br>
아무리 작업을 병렬화시켜도 병렬로 작업할 수 있는 부분과 그렇지 못한 부분은 고정적이기 때문에 성능 향상의 임계점이 존재한다.

**c10k 문제**<br>
동시에 1만 명이 서버에 접속할 때 트래픽을 어떻게 막을 수 있는가에 대한 문제<br>
과거 컴퓨터 사양으로는 스레드 1만 개를 견디지 못하였음

<br><br>

## ✏️ 동시성과 병렬성의 차이

**동시성**
- 동시에 실행하는 것처럼 보이도록 문맥 전환을 빠르게 수행
- 하드웨어 지원이 필요 없음
- I/O 작업 중심
- 문맥 전환에 따른 오버헤드 발생 → 공유 자원 측면에서는 이득 [멀티스레드]
- 한 코어 내부에서 동작할 때의 특성 [멀티스레드]

<br>

**병렬성**
- 물리적으로 동시에 수행
- 멀티 코어, 멀티 프로세서를 지원하는 등 하드웨어의 지원이 필요
- 연산 작업 중심
- 공유 자원의 동시성 문제 발생 가능성 [멀티 스레드]
- 여러 개의 코어를 사용해야 함 (하드웨어의 지원와 같은 맥락) [멀티 스레드]

<br><br>

## ✏️ 컨텍스트 스위칭이 발생할 때 생기는 부정적인 영향
- 오버헤드 발생 → 시간 지연 → 성능 저하
- 기존 작업을 중단하는 시점의 데이터 저장에 따른 비용

<br><br>

## ✏️ 프로세스 스케쥴링과 스레드 스케쥴링의 차이점

**프로세스 스케줄링**
- 하나의 CPU
- 독립적인 자원에 대하여 컨텍스트 스위칭

**스레드 스케줄링**
- 하나의 코어
- Stack 데이터에 대해서만 컨텍스트 스위칭

<br>

---

<br>

## 👀 느낀점

스케줄링 저거 정처기 볼 때 외웠던 건데 이게 그 내용이구나..~ 를 이번에 처음 이해함.<br>
얼마나 공부를 똥같이 했으면 ~<br>

근데 어제 동시성, 병렬성 이해 다 했다고 오늘 거 뭔가 자만하고 깊게 공부 안 한 거 같아서 흠...<br>
내가 제대로 안 한 거 자초했으면서 스트레스 받는 이 모순...~~<br>
근데 어제 ㄹㅇ 동시성 병렬성 다 이해했는데 또 다른 키워드가 제공되고 다르게 검색하니까 또 모르는 깊은 지식들이 나와서 너무 신기하다<br>
나는 너무 모르는 게 많고...~<br>
내일부터... 진짜 제대로 ㄱㄱ

뭔가 자바 코딩하던 사람들은 딱딱 알 것 같은데 나는 그게 아니라서 개념 따로 코딩 따로가 돼버리는...<br>
그래도 과제하면서 이해할 듯하다.

근데 뭔 강의가 이렇게 많은지... 살짝 지침 그래서 조사도 오늘 ㄹㅇ 대충하고 이것도 대충 쓰고... ~~ 주말에 해야지..<br>
나 이거 잘 할 수 있을까?

그리고 잠 좀.. 잘 자야겠다....

### 오늘의 라이즈
<img width="422" alt="Image" src="https://github.com/user-attachments/assets/1d36b6f6-481c-4588-a016-dde0a9a18093" />

