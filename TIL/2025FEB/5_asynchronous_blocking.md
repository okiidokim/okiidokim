# ✏️ 간단하게 정의 정리

### 동기
정의 : 한 번에 하나의 함수만 실행 가능

### 비동기
정의 : 한 번에 여러 개의 함수를 실행 가능<br>
병렬성<br>
관련 키워드 및 함수 : async, await, setTimeout() 등

### 블로킹
정의 : 제어권이 넘어갔을 때 해당 작업을 대기 상태로 바꾸는 것

### 논블로킹
정의 : 제어권이 넘어가더라도 다시 반환 받으며 두 작업 모두 대기 상태로 바뀌지 않는 것
<br>polling : 제어권이 있는 쪽에서 성공할 때까지 지속적인 종료 확인 시그널을 커널로 전송
<br>관련 함수 : readFile(), fetchData() 등

<br>

# **✏️ 파일 읽기 작업을 예시로 들어 동기 / 비동기의 차이**

### 동기 : 순차적으로 한 번에 하나의 작업만 가능함

```jsx
function doWorkSync() {
    const start = Date.now();
    while (Date.now() < start + 1000); 
    console.log('동기 작업 완료');
}
console.log('작업 시작');
doWorkAsync(); 
console.log('다음 작업');
```
1000ms의 지연이 있는 것은 동일하지만 자바스크립트 자체가 동기적으로 동작하는 언어이기 때문에 while문에 의해 1초의 시간이 while문 안에 갖혀 돌게 된다.<br>
`작업 시작` → `동기 작업 완료` → `다음 작업` 순으로 출력

### 비동기 : 병렬적으로 동시에 작업 가능함

```jsx
function doWorkSync() {
    setTimeout(() => {
	    console.log('비동기 작업 완료');
    }, 1000);
}
console.log('작업 시작');
doWorkAsync(); 
console.log('다음 작업');
```

setTimeout()함수 자체가 비동기를 지원하는 함수인데 1000ms, 1초 후에 처리하고 다음 작업은 setTimeout()함수의 종료 여부와 상관 없이 수행할 수 있다.<br>
`작업 시작` → `다음 작업`→ `비동기 작업 완료` 순으로 출력됨

<br>

# ✏️ 제어권 관점에서 블로킹과 논블로킹 설명

블로킹 : 함수 a에서 함수 b 호출 시 제어권이 넘어가고 함수 b의 반환을 통해 다시 함수 a로 제어권이 넘어옴<br>
논블로킹 : 함수 a에서 함수 b 호출 시 제어권이 넘어가지 않고 비동기일 경우 a의 실행과 b의 실행 후 콜백 함수의 실행이 동시에 일어남

<br>

# ✏️ 동기 + 블로킹과 동기 + 논블로킹 조합의 차이

### 동기 + 블로킹
제어권을 가진 입장 : 넘겨줄게. 실행하고 끝나면 다시 줘
<br>제어권을 받은 입장 : ㅇㅋ
<br>제어권을 받은 입장 : 실행 끝남. 다시 제어권 넘겨드림
<br>제어권을 가진 입장(다시 받음)

### 동기 + 논블로킹 (polling)
제어권을 가진 입장 : 너 함수 실행 끝남? - ㄴㄴ
<br>제어권을 가진 입장 : 너 함수 실행 끝남? - ㄴㄴ
<br>제어권을 가진 입장 : 너 함수 실행 끝남? - ㅇㅇ

### 비동기 + 블로킹
제어권을 가진 입장 : 넘겨줄게 근데 나 실행은 계속 할 거임
<br>제어권을 받는 입장 : ㄱㅅ 근데 너 제어권 없어서 실행 못함 ㅅㄱ
<br>→ 결국 동기 + 블로킹 엔딩

### 비동기 + 논블로킹
제어권 가진 입장 : 네 거 작업하고 내가 보내는 함수 실행 좀 해줘. 그리고 내 할 거 하게 제어권 좀 바로 다시 넘겨주고
<br>→ 내가 보내는 함수 : 콜백함수 (함수를 호출할 때 콜백 함수를 인자로 전달)

<br>

# **✏️ 비동기 I/O와 논블로킹 I/O의 차이**

https://velog.io/@nefertiri/Blocking-IO%EC%99%80-Non-Blocking-IO

### 비동기 I/O
입출력 작업 요청 후 반환을 받지 않은 상태로 두 작업을 동시에 수행
<br>종료 타이밍의 알림은 OS, 즉 백그라운드에서 함수 종료 알림 및 결과를 전송함

### 논블로킹 I/O
입출력 작업 호출 시 작업을 중단하지 않고 호출에 대한 결과를 먼저 즉시 반환 받은 다음 콜백 함수 및 다른 작업 수행하여 지속적인 폴링을 통해 커널에서 응답 결과를 전송한다.
<br>예를 들어 fetchData()의 경우 status 코드를 우선 먼저 반환한 이후에 내부 실행 결과를 반환한다. 이때 요청한 쪽의 다른 작업은 실행 중에 있다.

<br>

# ✏️ 멀티 스레드 환경에서 블로킹 I/O를 사용할 때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법

스레드의 동작 순서가 생성 → 실행 → 대기 → 종료의 흐름인데 그렇다면 블로킹은 한 스레드만 실행 상태인 거고 대기가 제어권 없는 스레들이구나 하는 생각에 도달했다. 그렇다면 블로킹 I/O에서 제어권을 넘겨주는 과정은 문맥 전환이기에 오버헤드가 발생한다. 
<br>동시성 문제를 해결하는 것은 어제 학습하였다. 그 중 lock을 걸 때 많은 오버헤드가 발생한다. 이때 오버헤드가 발생하지 않는 해결 방법이 있었다. Atomic 클래스를 사용하는 것.
<br>이는 CAS 알고리즘을 활용하기 때문에 CPU에 존재하는 값과 메인 메모리에 존재하는 값을 비교하여 같을 경우 참, 다를 경우 거짓을 반환하여 동시성 문제를 해결하는 동시에 오버헤드를 최소화할 수 있다.
<br>나의 생각을 뒤로 하고 다른 방법들이 있는지 찾아보았다.

https://developer-syubrofo.tistory.com/282<br>
https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better#i/o_%EB%B0%94%EC%9A%B4%EB%93%9C_%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98 → [i/o_바운드_어플리케이션]부분<br>
- 멀티 스레드 모델 대신 비동기 I/O 처리에 특화된이벤트 기반 프로그래밍 모델 (node.js가 대표적)

> 싱글 스레드 + 이벤트 기반 프로그래밍 모델에서는 이벤트 루프로 이벤트를 감지하고, 이벤트 핸들러를 호출하여 해당 이벤트를 처리한다. 입출력 작업을 수행 시 이벤트 핸들러는 비동기 I/O를 사용하여 입출력 작업을 수행하고, 입출력 작업이 완료될 때까지 이벤트 루프를 블로킹하지 않는다. 그래서 작업 처리 도중 다른 작업을 처리할 수 있어서, 멀티 스레드 모델에 비해 더 적은 리소스를 사용하고 높은 처리량을 보여줄 수 있다.
> 
<br><br>
https://jinn-blog.tistory.com/208

- 스레드 풀
- 효율적인 비동기 프로그래밍
- lock 최소화

<br>

# ✏️ 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점

fetchData()와 같은 함수를 사용하면 요청에 대한 응답 성공 여부를 즉시 받아 사용자에게 반환하는 동시에 요청을 보낸 쪽의 작업은 중단되지 않아 명확하고 답답하지 않은 사용자 경험을 제공한다.<br>
로딩 시간이 2초만 되어도 사용자 경험이 90% 이상 떨어진다는 결과가 있다. 만약 블로킹 방식이라면 요청 보낸 쪽의 작업은 수행되지 않아 속도가 느려 좋은 사용자 경험을 제공하지 못하게 된다.

<br>

---

<br>

# 😲 케빈과의 질답 시간

1. 작업 = 함수?
    - 파일 읽기 - 자바 프로그램 내부에 있는 게 아니라 OS에 요청 → 요청 자체의 단위 : 작업
    - 함수라고 하면 할 수 있는데 OS 차원에서 직접 다루어지는 작업
2. 스레드가 함수가 아니라면 클래스와 같은 다른 단위로 볼 수 있는 게 있나?
    - 스레드 - 코드, 함수, 클래스로 구현할 수 있지만 시스템 레벨에서도 존재하는 도구
3. 스레드 클래스와 고유명사 스레드는 좀 다른 의미?
    - 다르진 않음
    - 스레드 정의 자체 ) 어떤 식으로 존재하고 올라가는지 → 흐름을 되짚어 보기
    - 코드레벨의 스레드와 시스템 상에서의 스레드를 같지만 다르게 이해하고 코드에서 작성된 스레드가 시스템에 어떻게 적용되는지 흐름 그려보기
4. 함수를 보았을 때 논블로킹인지 비동기인지 구분할  수 있나?
    - Ctrl 누르고 함수 타고 들어가서 실제 구현을 볼 수 있으니 그걸 보면 알 수 있음
5. 논블로킹 = 스레드의 병렬성이라고 볼 수 있는가?
    - ㅇㅇ 근데 직접 더 공부해 보는 게 좋을 것

<br>

---

<br>

# 👀 느낀점

일요일에 이래저래 궁금한 거 찾아보다가 동기, 비동기에 대해 간단하게 알아봤는데 갑자기 오늘 수업 내용이어서 놀랐다. 블로킹, 논블로킹 단어는 그냥 귀찮아서 지나갔었는데 오늘 이렇게 디테일하게 공부하게 될지 몰랐다.

어제 배운 스레드와 오늘 배운 내용이 처음에는 연결되는 내용이라고도 생각하지 못했고 오늘 내용이 너무 헷갈리기도 했고 어제 컨디션 이슈로 스레드에 대한 완전 정복을 하지 못해서 좀 오래 해멨다. 근데 키워드 정리하다가 “멀티 스레드 환경에서 블로킹 I/O를 사용할때 발생하는 컨텍스트 스위칭 오버헤드를 줄이기 위한 방법”이라는 선택 질문을 보고 ‘아 이거 어제랑 연결되는 구나’를 깨달았다. 그러다 보니 어제와 오늘 내용을 연결하여 생각하게 되었다. 

그리고 더 집중하고 찾아보다 보니 처음에 논블로킹 개념을 “한 번에 여러 개의 작업에 제어권을 할당할 수 있는 것”이라고 오해했는데 제어권은 하나라는 걸 로직을 통해 이해하고 나니 비동기와 논블로킹의 차이가 이해됐다. 역시 모를 땐 좀 쉬기도 하고 한 발 멀리서 보고 다시 돌아오면 좋은 것 같다. 개념 정리하다가 갑자기 스레드랑 연결된 의문으로 시간을 보내다가 돌아오니 잘못 정리한 개념이 보였기 때문!

오늘 원래 2/3 거 하나도 몰라서 그거까지 하려 했는데 동생 생일이기 때문에 이만 여기까지~ 근데 오늘 내용 너무 재밌다. 명확하지만 헷갈린 걸 스스로 체화하면서 명확하게 만들 때 희열을 느끼는 편 하하
