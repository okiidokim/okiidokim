## 교착상태/기아상태

### 교착상태

과제하면서 입력했는데 다음에 아무것도 안 일어나는 게 아 데드락이구나 확인<br>
여러 작업 간 순서가 꼬여 서로 점유한 자원을 대기하는 상태에서 점유할 수 없어 프로세스가 정지된 상태<br>
스레드 A의 자원 C 점유 → 스레드 B의 자원 D 점유 → 스레드 A의 자원 D 요청 대기 → 스레드 B의 자원 C 요청 대기 → 서로 대기 데드락

[조건]<br>
1. 상호 배제<br>
2. 비선점<br>
3. 순환 대기<br>
4. 점유 대기<br>

### 기아상태

프로그램은 잘 돌아가고 있는데 요청 보낸 작업의 우선순위가 너무 낮아 계속 실행되지 못하는 현상<br>
우선 순위가 포인트

데드락과 반대말이라고는 하는데 그렇게 들으면 오히려 이해가 안 되는 느낌이었다.<br>
교착 상태는 서로 대기한다고 아무 것도 실행 자체가 안 되는 거고 기아 상태는 내가 너무 후순위여서 다른 건 다 실행되는데 내 차례가 안 온다 이렇게 생각해야 할 듯?

---

## 경합 조건

다수의 작업의 동시에 공유 자원을 점유하려 할 때 우선순위를 몰라 둘 이상의 작업의 결과를 알지 못하는 문제<br>
스레드 A의 1, 2, 3작업과 스레드 B의 작업 4, 5, 6이 있을 때<br>
1, 2, 3, 4, 5, 6 중 어느 작업이 먼저 실행되는지 모름 → 1 2 4 3 5 6 , 1 2 3 4 5 6의 결과가 다를 수 있는데 우리는 이 결과를 알지 못함

→ 이를 해결하는 조건 : 상호 배제, 진행, 유한한 대기

---

## lock-free/wait-free

[lock-free]<br>
낙관적 락 = CAS 알고리즘(Compare and Swap)?<br>
기대값과 실제 결과 값 비교 → 다르면 충돌 감지 → 롤백, 같으면 다음 요청

[wait-free]<br>
작업이 동시에 점유하려고 해도 대기 없이 실행 가능한 알고리즘<br>

Atomic 클래스<br>
![image.png](attachment:254cfa91-126d-470a-98d4-46fe216a3c16:image.png)<br>
https://worthpreading.tistory.com/90

---

## 뮤텍스 vs 세마포어

### 뮤텍스

공유자원에 접근할 수 있는 스레드 수 : 1개

### 세마포어

공유자원에 접근할 수 있는 스레드 수 : n개 (정할 수 있음)<br>
공유자원에 접근할 수 있는 스레드 수만큼 차지 않았다면 요청 스레드에 알림을 보내서 접근할 수 있게 함<br>
!!스레드풀이랑은 다름 - 아래 추가 질문에 관련 내용 있음!!

<br>

---

<br>

## 추가 질문

1. **공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.**
    
    여러 작업(+ 사용자가)에서 공통으로(동시에 접근하는) 사용하는 시스템의 데이터 및 자원<br>
    자원 관리의 효율성 때문에 사용한다.<br>    
    공용 화장실에서 변기 칸을 사람이 들어올 때마다 만들면 사람이 적을 경우엔 변기 칸 병목 현상이 있을 것이고 계속 변기칸 만드는 데 많은 시간과 비용이 들 것이다.
    
2. **임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?**
    
    정의 : 공유 자원에 접근하는 프로그램 코드의 일부분<br>   
    임계영역의 보호함으로써 데이터 무결성을 보장할 수 있다.<br>
    중복 수정으로 인한 동시성 문제가 발생할 수 있다.
    
3. **동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.**
    
    주 목적 : 데이터 일관성<br>
    동기화의 목적 자체에 데이터 무결성이 있다. 데이터 충돌이 발생하게 되면 기대값과 다른 값이 결과로 나올 수 있는데 이는 데이터 무결성을 해친다. <br>
    데드락이 발생할 수도 있고… ~~
    
4. **락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.**
    
    정의 : 공유자원에 동시에 접근하는 작업 중 하나의 작업만 공유 자원을 점유할 수 있도록 제어하는 동기화 메커니즘<br>    
    다른 작업으로 인해 한 작업 원자성이 깨지면 충돌로 인해 기댓값으로 처리되지 않을 가능성이 있다.<br>    
    때문에 하나의 작업이 공유 자원을 점유할 때 다른 작업은 공유 자원에 접근하는 것을 차단하여 각 작업이 깨지지 않게 무결성을 보장한다.
    
5. **뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.**
    - 뮤텍스 : 한 번에 하나의 작업만 공유자원에 접근<br>
        뮤텍스 대기 큐가 있으니까 스레드에 직접 알람이 아니라 대기 큐에 이제 되니까 들어와~ 하는 거
        
    - 세마포어 : 한 번에 공유 자원에 접근할 수 있는 작업의 수를 제한해 둠 → 스레드풀의 적용<br>
        알림을 보냄<br>        
        n개의 스레드 접근이 가능하고 전부 점유하고 있다가 하나의 작업이 완료돼서 n-1이 됐는데 이제 signal()을 보냄
        
6. **조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.**
    
    조건변수 대기 큐와 뮤텍스 대기 큐가 있는데 둘의 역할이 다르다.<br>    
    조건 변수 대기는 배타적 접근을 확인하는 역할이 아니다. 해당 작업이 실행 가능한지에 대한 여부만 확인한다.<br>
    그래서 실행 가능한 조건이어도 다른 스레드가 점유하고 있다면 뮤텍스 대기 큐에 in된다.
    
7. **뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.**
    
    [조건]<br>
    1. 점유 대기 → 공유자원을 점유한 동시에 다른 공유자원의 점유가 해제될 때까지 대기<br>
    2. 비선점 → 다른 작업의 실행 권한(제어권)을 중간에 뺏지 않음<br>
    3. 순환 대기 → 원으로 서있고 모두가 왼쪽 사람을 기다릴 때(예시) - 기다리고 있으니까 아무도 다가오는 사람이 없음<br>
    4. 상호 배제 → 하나의 공유자원에는 하나의 작업만 접근 가능해야 함
    
    [예방]<br>    
    1. 최소 한 사람은 다른 방향으로 서있게 한다. (순환되지 않게 하나의 작업을 강제함)<br>
    2. 접근 제한을 풀어 병렬적으로 작업이 요청할 수 있게 한다.<br>
    3. 문맥 전환을 최소화한다. - 스레드 풀을 사용하거나 Atomic, lock-free 알고리즘을 사용한다.<br>
    
7. **낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.**
    
    매우 저하됨<br>
    충돌 발생 시 이전으로 롤백하는데 일종의 lock-free한 동기화 메커니즘<br>
    여러 스레드가 동시에 접근할 수 있어 병렬성이 극대화 된다는 장점이 있지만<br>    
    기댓값과 메모리(공유 자원)에 저장된 값이 다르면 충돌이 발생하였다고 “감지”하여 충돌이 발생한 작업의 처음으로 돌아가 다시 실행한다.<br>
    이러한 롤백이 반복되면 실행 시간이 많이 늘어나 성능이 많이 저하될 것이고 이에 따른 CPU 낭비, 비용의 단점이 존재한다.<br>
    
8. **데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.**
    
    스레드 풀은 미리 스레드 개수만큼 만들어두고 생성, 소멸에 대한 오버헤드를 없앤다.<br>    
    반면 세마포어는 한 번에 실행할 수 있는 스레드 개수를 정할 수 있는데 결국 매번 스레드를 생성하고 소멸하기 때문에 오버헤드는 작업마다 모두 발생한다.<br>
    때문에 스레드 풀을 통해 한 번에 실행할 수 있는 스레드 개수만큼 스레드를 만들어두어 오버헤드를 줄이고 스레드 풀이 전부 가득차지 않았을 때 대기 중인 스레드에 signal을 보내서 효율적으로 제어할 수 있다.
    
9. **JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?**
    
   우선 뷰, 리액트 다양하게 있겠지만 리액트가 익숙하기 때문에 리액트를 기준으로 생각해 보겠다.<br>
   상태 관리라고 하면 사실 리액트에서 useState()만 사용해 보았다.<br>    
   const [num, setNum] = useState(0); 이런 거 진짜 많이 써봤는데 데이터 바꾸고 콘솔에 출력할 때 반영이 안 되는 경우가 많았다 setNum()으로 변경해도 잘 안 되는 경우도 많았고..~<br>
   근데 이게 다 리액트 함수의 일괄 처리 때문이었다는 게 신기하다. 왜 한 번도 제대로 알아볼 생각을 안 했는지 모르겠다.<br>
   사실 상태 관리라는 단어도 거의 몰랐고 비동기? 관련 있을 거라고는 생각도 못했다. 그저 화면 꾸미기^^라고 생각했을 뿐<br>
   프론트도 깊게 배우면 재밌을 것 같다.<br>
   사실 이거 확 공부하고 정리하고 싶은데 오늘은 여기서 쉬는 걸로..~~<br>
   https://sung-98.tistory.com/119
    
11. (선택) 분산 락(Red Lock)
    
    락을 소유한 작업만이 공유 자원에 접근할 수 있는 동기화 메커니즘 → 뮤텍스 아닌가? (락 소유권, 해제권을 가짐)<br>
    레디스, MySQL
    

| 단어 | 정의 | 비고 |
| --- | --- | --- |
| 공유 자원 | 여러 프로세스나 사용자가 접근할 수 있는 시스템의 자원 | - 메모리 → Heap, Code, Data <br>- 파일 시스템<br>- 데이터 베이스 |
| 임계영역 | 공유 자원에 접근하는 코드의 일부분 | Critical Section |
| 동기화 | 동시에 여러 작업이 공유 자원에 접근할 때 충돌이 발생하거나 데이터 무결성이 손실되는 문제를 제어해 데이터의 일관성을 보장하는 메커니즘<br>[목적]<br>- 데이터 무결성<br>- 데드락<br>- 데이터 경합 | [조건]<br>1. 유한한 대기<br>2. 진행<br>3. 상호 배제<br>[종류]<br>1. 뮤텍스/락<br>2. 조건 변수<br>3. 세마포어 |
| 락 | 하나의 작업이 공유 자원을 점유하였을 때 다른 자원은 공유 자원에 접근하지 못하도록 제어하는 동기화 메커니즘 | [동작 과정]<br>1. 스레드 A의 공유 자원 요청 → A의 자원 점유 → Lock 소유<br>2. 스레드 B의 공유 자원 요청 → 접근 불가 → 대기<br>3. A의 작업 완료 → Lock 해제<br>4. B의 자원 요청 → 점유 |
| 원자성 | 하나의 작업은 쪼개질 수 없는 연산/작업으로 이루어져야 한다는 특성<br><br>⇒ 하나의 작업은 다른 작업에 의해 쪼개지지 않고 반드시 한 번에 이루어져야 함 | - [i++] : i를 읽은 후 ++연산 → 2번의 작업 (읽기 + 쓰기)<br>- [i += 1] : i에 1을 더하는 작업 → 1번의 작업 (쓰기) |
| 상호 배제 | 한 작업이 공유 자원을 점유하였다면 다른 작업은 점유할 수 없음 | - 배타적 접근 |
| 진행 | 2개 이상의 작업이 대기 중이며 공유자원을 점유한 작업이 없다면 반드시 하나는 공유 자원을 점유해야 함 | - 밀리지 않게 공유자원 주인이 없으면 빨리 빨리 다음 순서가 가져가야 함 |
| 유한한 대기 | 자원을 요청한 작업은 반드시 점유해야 함 | - 무한한 대기 금지 → 대기 큐 |
| 데드락 | 작업 간 순서가 꼬여 무한 대기에 빠지는 현상<br><br>[발생 조건]<br>상호 배제, 선점, 점유 대기, 순환 대기 | = 교착 상태<br>→ 한 스레드가 점유하는 스레드 A가 B대기, 다른 스레드가 점유하는 B가 A를 대기 → 작업이 꼬여 서로 대기하는 상태<br>→ 프로세스를 종료해도 흔적이 남음 |
| 기아 현상 | 작업의 우선순위가 너무 낮아 자원을 공유 받지 못하는 현상 | ↔ deadlock(교착상태) |
| 경합 조건 | 요청한 여러 작업 중 우선순위를 몰라 두(둘 이상) 작업의 결과를 예측하기 어려운 문제<br><br>→ 우선순위를 모르긴 하지만 1, 2, 3, 4, 5, 6의 경합 조건을 만족하지 않으면 잘못된 결과를 도출할 수 있음 | [상황]<br>둘 이상의 작업이 동시에 공유 자원에 접근할 때 스레드A의 작업 순서 1, 2, 3과 스레드 B의 작업 순서 4, 5, 6이 있다고 가정할 때<br><br>→ 상호 배제, 진행, 유한한 대기 조건을 충족해야 함<br>▶️ 1, 2, 3이 진행될 동안 4, 5, 6은 진행될 수 없음<br>→ 원자성 보장 : 123, 456은 한 묶음으로, 찢어지면 안 됨<br>▶️ 1, 2, 3의 작업이 완료되면 4, 5, 6은 반드시 진행돼야 함<br>▶️ 4, 5, 6은 1, 2, 3을 무한히 대기하지 않아야 함(데드락 안 돼) |
| lock-free/wait-free 알고리즘 | [lock-free]<br>락을 걸지 않고 동시성 문제를 해결하는 알고리즘<br>- CAS 알고리즘 (Compare And Swap)<br>→ 변화를 감지하지 못할 수 있으나(ABA) 오버헤드 없음<br>→ 충돌이 없는 곳에서 효율적, 낙관적 락? | [wait-free 알고리즘]<br>작업의 대기 없이 동시성 문제를 해결하는 알고리즘<br>- Atomic (< lock-free)<br>- 하드웨어 자체에서 막는 건 있지만 지연없음<br>→ 가장 빠름 |
| 스핀락 | 한 스레드가 락을 걸어 공유자원을 점유하고 있을 때 락이 해제될 때까지 다른 스레드는 요청을 반복하는 메커니즘 | [장점]<br>실행시간이 짧을 경우 오버헤드 없어서 효율적<br>커널 내부 구현에 적용<br><br>[단점]<br>실행시간이 길 경우 CPU 낭비가 심해짐 |
| 낙관적 락 | 충돌이 발생하지 않는다는 가정 하에 락을 걸지 않고 충돌 발생 시 롤백하여 다시 실행하는 메커니즘<br><br>→ lock-free | [장점]<br>락을 걸지 않아 오버헤드 없음<br>병렬성 극대화<br><br>[단점]<br>충돌 발생 시 성능 저하 |
| 뮤텍스 | 한 번에 하나의 작업만이 공유자원을 점유할 수 있도록 제어하는 동기화 메커니즘<br><br>- 상호배제 조건<br>- Lock 소유권 + 해제권을 함께 가짐 | [동작 과정]<br>1. 스레드 A 요청 → 스레드 점유, 락 소유<br>2. 스레드 B 요청 → 뮤텍스 대기 큐 진입<br>3. 스레드 A 작업 완료 → 락 해제 → 큐 notify()<br>4. B(큐의 첫번째 작업 가정) 요청 → 점유, 소유<br><br>[장점]<br>데이터 무결성 보장<br><br>[단점]<br>오버헤드 |
| 조건변수 | 작업의 실행 조건이 만족될 때 공유자원을 점유할 수 있도록 알람을 전송하는 동기화 메커니즘<br><br>- 진행 조건<br>- 뮤텍스와 일반적으로 함께 사용 | [동작 과정]<br>1. 스레드 A 요청 → 스레드 점유, 락 소유<br>2. 스레드 B 요청 → 조건 변수 대기 큐 진입 - wait()<br>3. 스레드 A 작업 완료 → 락 해제 → 큐 signal()<br>4. 스레드 C 요청 → 스레드 점유, 락 소유<br>5. B(큐의 첫 번째 작업 가정) → 뮤텍스 대기 큐 진입<br>6. 스레드 C 작업 완료 → 락 해제 → 큐 notify()<br>7. B(큐의 첫 번째 가정) 요청 → 점유, 소유 |
| 리드-라이트 락 | 읽기 작업과 쓰기 작업을 분리하여 제어하는 동기화 메커니즘 | - 읽기 작업의 병렬성<br>- 쓰기 작업의 독립성<br>[장점]<br>읽기 작업의 병렬성<br>읽기가 많고 쓰기가 현저히 적은 상황에서 사용<br><br>[단점]<br>읽기 - 쓰기 순서에 따라 데드락 발생 가능성 |
| 세마포어 | 동시에 작업할 수 있는 스레드의 개수를 정해서 알림을 제공하고 제어하는 동기화 메커니즘 | - 상호 배제 + 유한한 대기 조건<br>- 접근 가능한 스레드 개수의 자리가 남으면 요청 스레드에 signal() |
| (선택) 분산 락 | 락을 소유한 작업만이 공유 자원에 접근할 수 있는 동기화 메커니즘 | - Red Lock<br>- 레디스, MySQL<br> → 뮤텍스 아닌가? (락 소유권, 해제권을 가짐) |

<br>

---

<br>

## 👀 느낀점

크램폴린 강의는 하나도 안 들었다. 사실 귀에 안 들어옴...<br>
그래서 어제 공부를 덜한 동기화, 락 부분을 공부하였다.

오늘도 농땡이 많이 피웠지만 확실히 잠은 6시간은 자니까 살맛 난다.<br>
진짜 3시 전에 잔 건 최고의 선택이었다. 앞으로도 그럴 것.<br>
근데 이틀동안 공부하니 어제 거 복습도 되고 진짜 머리에 잘 남는 느낌이다.<br>

그리고 종이에 적으면서 공부하기 시작했는데 훨씬 좋다.<br>
훨씬 깔끔하고 정리도 잘 되는 기분<br>
한 줄정리도 나름 야무지게 한 것 같은데 표가 너무 커서 깃허브에만 올려야겠다 후후.

그리고 아예 안 보고 내 머리에 있는 대로 오늘 배움일기 최대한 채워봤다.<br>
물론 9, 10번은 그러지 못했지만 그래도 서술형 질문 보고 좀 생각해 보고 와르르 쓸 수 있다는 게 조금의 발전이라고 생각한다.
물론 틀린 게 많을 수도 있지만...ㅎㅎ

OS가 실제 코딩과 연결되니 정말 재밌어졌다. 그래도 빨리 웹 기초 배우고 싶다는 생각도 있다.

### 오늘의 라이즈
<img width="423" alt="스크린샷 2025-02-12 오전 1 21 56" src="https://github.com/user-attachments/assets/017fbedc-b55b-47d5-b8a0-2b313bcf2ef1" />
