## ✏️ INDEX

- 정의 : 테이블에서 조회할 때 성능을 향상시키기 위한 키 (aka. secondary key)
- 목적 : 빠른 정렬 및 조회
- 탄생배경 : PK만으로 조회 성능이 떨어지는 걸 해결
- 특징
    - like 목차
    - WHERE, ORDER BY, GROUP BY를 효율적으로 하게 함
    - PRIMARY KEY, UNIQUE 적용된 속성에는 자동으로 인덱스 생성됨
    - 조회 성능이 빠름
    - 무분별한 사용으로 오히려 성능이 느려질 수 있음
- 활용 예시 (사용 방법)
    
    ```sql
    CREATE INDEX index_email on students(email);
    
    SELECT * from students where email = 'daisy@naver.com';
    ```
    
    - students 테이블의 email 컬럼에 대한 인덱스를 할당
    - 실제 index_email 컬럼이 테이블에 생기는 것이 아님
    - 인덱스는 별도의 **B-Tree**로 관리됨
    - `like ‘%검색어’;`
        - %부분은 전수 조사이기 때문에 느림, 인덱스 무용지물
        - `‘검색어%’` 일때는 검색어 부분에서 인덱스 사용됨
    - `explain` 키워드로 어떤 인덱스를 사용하였는지, 인덱스 사용 여부 확인 가능
- 종류
    1. 클러스터형 인덱스
        - 인덱스 대로 실제 데이터 정렬을 물리적으로 갱신함
        - 때문에 인덱스 페이지 없이 테이블에서 직접 조회
        - 한 테이블에 하나만 있을 수 있음
        - insert, update, delete 등 데이터 갱신될 때마다 정렬도 갱신돼야 하는 오버헤드 발생
    2. 비클러스터형 인덱스
        - 포인터형 인덱스로 데이터 구조에서 물리적인 정렬을 갱신하지는 않지만 인덱스 페이지가 있음
        - 인덱스 페이지에서는 정렬된 데이터들이지만 개발자가 볼 수 없음
        - 인덱스 예시 ) 2페이지 3오프셋 = 2번째 페이지의 3번째 데이터
        - “인덱스”라 하면 일반적으로 비클러스터형

<br>

## ✏️ B-Tree / B+Tree

https://www.youtube.com/watch?v=LnxEBW29DOw

### ▶️ B-Tree

- 정의 : 트리의 높이를 일정하게 유지시키는 트리
- 특징
    - 이진 트리와 달리 자식 노드를 3개 이상 가질 수 있음
    - B는 Balanced일 수도, Broad일 수도
    - DB 인덱스에서 많이 사용
    - 검색, 삭제, 삽입 시간 복잡도 : O(logN)
    - 대용량 데이터 처리에 유리

### ▶️ B+Tree

- 정의 : 트리의 높이를 일정하게 유지하되 각 노드에는 인덱스가 저장되며 최하위 노드에만 데이터가 저장되는 트리
- 특징
    - InnoDB에서 클러스터링 인덱스으로 사용
    - 인덱스 페이지에서 사용된다고 할 수도 있음
    - 리프노드끼리 연결리스트로 연결돼있음

<br>

## ✏️ 카디널리티

- 정의 : 속성의 고유값 개수
    - “성별”이라는 속성의 카디널리티는 일반적으로 남, 여 2개
    - 남, 남, 여, 남 → 4개가 아님
- 특징
    - 카디널리티가 높은 속성이 검색 효율이 좋음
    - 카디널리티가 높은 속성이 중복도가 낮음

<br>

## ✏️ 트랜잭션

- 정의 : DB에서 하나의 처리를 위해 수행되는 작업 모음 단위
- 동작 과정
    1. `BEGIN TRANSACTION;`
    2. 삽입/삭제/수정의 sql 실행
    3. 성공 시 `PARTIALLY COMMITED` → `COMMIT;`
    4. 실패 시 `ROLLBACK;`
- 상태 종류
    - Active : 트랜잭션 실행 상태
    - Partially Committed : 트랜잭션의 모든 작업이 끝나고 Commit만 남은 상태로 아직 DB에 영구적으로 반영되지 않음
    - Failed : 트랜잭션 실패 상태, 오류나 실패, 기타 문제가 발생하여 더이상 트랜잭션을 수행할 수 없음
    - Aborted : failed이후 rollaback 명령어가 실행된 상태
    - Committed : partially committed 이후 실제 DB까지 트랜잭션이 반영된 상태로 완전 성공

<br>

## ✏️ ACID

- 정의 : 안전한 트랜잭션을 보장하는 특징
- 종류
    1. ATOMICITY(원자성) : 트랜잭션은 한 번에 수행되거나 아예 수행되지 않아야 함 (철회되거나)
    2. CONSISTENCY(일관성) : 트랜잭션 수행 전후 데이터 상태는 일관돼야 함
    3. ISOLATION (독립성) : 서로 다른 트랜잭션은 서로 영향을 미치지 않고 독립적임
    4. DURABILITY (지속성) : 트랜잭션이 수행된 후 결과는 영구적으로 지속돼야 함

### ▶️ isolation level

- 정의 : 트랜잭션 고립 정도에 따른 분류의 정의
- 목적 : 완전한 독립성을 유지하면 한 번에 하나씩 수행되는 지연이 발생함에 따라 어느 정도 트랜잭션 간 독립성을 완화하여 동시성을 확보하기 위함
- 수준(레벨)
    1. Read Uncommitted : commit/rollback되지 않은 데이터까지 조회
        - Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
    2. Read Committed : commit된 데이터까지 조회하며 다른 트랜잭션 수행을 막지 않음
        - Non-Repeatable Read, Phantom Read 발생 가능
        - Non-Repeatable Read : 한 트랜잭션 내에서 같은 데이터를 다시 조회할 때 다른 트랜잭션의 commit 여부에 따라 값이 변할 수 있음 → 트랜잭션 일관성 깨짐
    3. Repeatable Read : 특정 제어 메커니즘으로 데이터가 변경되지 않게 하지만 새로운 데이터에 대한 결과를 막지는 못함
        - Phantom Read 발생 가능
        - 대표적 제어 메커니즘 : MVCC, Locking
    4. Serializable : 처리 성능이 가장 낮으며 각 트랜잭션이 순차적으로 수행됨

→ 이거 너무 어렵군… 오늘은 일단 이 정도만 하고 넘어가기

<br>

## ✏️ NoSQL(Not only SQL)

- 정의 : SQL만을 사용하지 않는 다양한 유형의 DB
- 목적
    - 데이터 다양성, 대규모 데이터 처리, 수평 확장 효율성, 유연한 설계
- 특징
    - 고정된 스키마 없이 구조적, 비구조적 데이터 등 다양한 데이터 처리 가능
    - 대규모 데이터 처리 가능
    - 모바일의 등장에 따라 많이 사용
    - 클라우드의 실시간 확장이 가능하며 RDBMS에 비해 수직 확장 비용 효율성이 높음
    - 다양한 데이터 모델을 지원하여 유연하고 효율적인 설계 가능
    - ACID보다 CAP 이론 적용
- 사용 방법
    - Redis : 키 - 값 저장소 (+ DynamoDB)
    - MongoDB : 문서 지향 DB
    - Cassandra : 컬럼 기반 DB
    - Neo4j : 그래프 DB
- 수평 확장 : 서버의 개수를 늘리는 것 → 병렬 처리로 성능 향상

<br>

## ✏️ Evential Consistency

- 정의 : 중간에는 일관성이 깨지더라도 결국 마지막에는 일관성이 유지된다는 분산 시스템의 일관성 모델
- 목적 : 가용성(Availabilty), 확장성(Scalability)
    - 가용성 : 서버가 다운되지 않게 함 → 분산 시스템으로 귯
    - 확장성 : 트래픽 증가에도 성능 저하 없도록 함
- 특징
    - 즉각적인 일관성에 초점을 두지 않음
    - NoSQL에서 주로 사용
    - 수평 확장에 용이

<br>

## ✏️ CAP 이론

- 정의 : 일관성, 가용성, 네트워크 분할 허용 오차 세 가지 중 두 가지만 만족시킬 수 있다는 이론
- 목적 : 분산 시스템이 특정 상황에서 어떤 걸 선택해야 할지 결정하는 기준으로 적용하기 위해
- 특징
    - 세 가지는 트레이드 오프 관계
    - 네트워크가 안정적일 때는 일관성과 가용성을 동시에 보장할 수 있지만 네트워크에 장애가 발생하면 일관성과 가용성 중 하나를 선택해야 함
    - 서비스 특징에 따라 상황에 따라 선택이 달라짐

<br>

## ✏️ 객체지향 4대요소 (면접에서 답변한다 생각하고 간결하게 정리)

1. 상속 : 한 클래스의 함수, 속성을 물려 받는 것, 공유하여 사용
2. 추상화 : 인터페이스와 추상 클래스에 메서드 시그니처만 정의하여 구체적인 구현부 없이 기능을 사용할 수 있게 하는 것
3. 다형성 : 오버로딩, 오버라이딩과 같이 다양한 형태로 동작 가능하게 하는 성질
4. 캡슐화 : 굳이 공개할 필요 없는 구체적인 구현체나 레거시를 인터페이스나 추상 클래스 하위에 은닉하거나 감싸서 구현하는 것

→ 이거 진짜 하나도 안 보고 적어봄

<br>

---

<br>

## 👀 느낀점

한 줄 정리 이거 할 때마다 최소 4시간은 걸리는 것 같다.<br>
오늘 DB가 이틀만에 끝나서 아쉽다.<br>
근데 뭐 어제도 생각한 거지만 반복학습은 중요한 것 같다.<br>
4번째 DB 가볍게 보니까 이제야 좀 거의 알 것 같다는 거~<br>
그리고 어제 한 번 보고 오늘 또 한 번 더 트랜잭션에 대해 더 알아보니 머리에 더 잘 들어오고 새롭게 들어온다.<br>
한 번 볼 때, 두 번 볼 때, 세 번 볼 때 다 다르게 느껴지는 게 항상 신기하다.

그리고 자료구조가 DB에 사용되는지 전혀 몰랐다.<br>
그냥 자료구조는 코테를 위한 이론일 뿐 오늘 트리 하길래 뭐지 알고리즘 알려주나? 했다.<br>
근데 인덱스에 사용된다니, 사실 “정렬”인데 뭐… 자료구조 사용되는 건 당연한 거였다.<br>
역시 따로 배우면 이게 같이 생각하는 게 잘 안 된다.<br>
근데 이렇게 융합되는 거 보일 때마다 좀 더 재밌어짐

그리고 후반에 Spring 할 때 정말 아무것도 몰라서 놀랐다.<br>
근데 빈 들었을 때 익숙한데 뭐지 했다가 학교에서 java로 플젝할 때 사용자 관리할 때 모델로 사용할 userBean 파일 만들어서 user 객체 싱글톤으로 반환하는 그런 거 생각났다.<br>
그거 말고는 진짜 아무것도 모름<br>
겁나는데 빨리 더 배워서 프론트 할지 백 할지 결정하고 싶다.

오늘 케빈이 관상을 봐줬다.<br>
- 확신의 백엔드 상, 근데 프론트 20 백 80 정도?
- 일 묵묵하게 잘함
- 티 안 냄
- 디테일 잘 봄
- 백엔드 조직 안에서 행사할 때 준비, 디테일 챙길 때, 스태프 같음
- 적극적으로 앞에 나서지는 않음

대애충 이런 식으로 말씀해 주셨는데 정확해서 놀랐다.<br>
멍석 제대로 깔리면 아무것도 못하는 스타일이라 적극적으로 앞에 나서지는 않지만 나중에 알고 보니 앞에 나서 있었다? 생각보다 재밌음 근데 나서야지 하고 나서는 건 힘듦<br>
그리고 학교에서 스태프처럼 일한 경험 정말 많다. 생각해 보니 2일에도 종각 가서 촬영 스태프 마냥 있다가 옴

근데 백엔드 상 프론트엔드 상 이거 진짜 궁금했는데 너무 고민된다.<br>
최근 일주일 정도 프론트해야 하나 이러고 있었는데 백엔드 상이란 말 들으니까 진짜 제대로 해볼까 하는 생각도 들고….<br>
재밌을 걸 이미 알아. 근데? 마음이 급해서 또 그럴 여유는 없음<br>
근데 또 하고 싶음….<br>
앞으로 일주일동안 Spring 열심히 해봐야겠다.

그리고 오늘 추가 질문은 패스..~~<br>
내일부터 스프링 화이팅~!!!!!!
