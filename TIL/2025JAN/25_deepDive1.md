# ✏️ 자바에서 OOP와 추상화, 캡슐화에 대해 정의하고 추상화와 캡슐화의 차이점에 대해 서술하시오.

## OOP (Object-Oriented Programming) - 객체 지향 프로그래밍

[문제 상황]
- 절차 지향적 코딩은 변경에 너무 많은 시간 투자 및 부담이 필요
하지만 사용자의 요구 변경은 끊임없이 발생<br>
    → 걍 스노우볼 되는 겨..~
- 복잡한 문제를 모두 절차적으로 다루는 데 한계가 있음

[예시] (좀 억지 예시긴 하지만^^)
- 식당 알바생 중 한 사람이 설거지 할 때, 퐁퐁 → 헹구기의 과정을 모두 담당<br>
    → 이때 알바가 그만 두고 새로운 알바가 들어옴
- 새로운 알바에게 퐁퐁, 헹구기 둘다 가르쳐 줘야 함

⬇️ 객체 지향이 도입된다면?
- 두 사람 중 A가 퐁퐁, B가 헹구기를 담당하고 A가 그만 두었을 때
- 새로운 알바 C에게 퐁퐁하는 방법만 알려주면 됨
- 누구 한 명 그만 두었을 때 가게에 미치는 영향과 새로운 알바생의 위험 부담이 덜 함 → SOLID의 OCP가 떠오름<br>
    → “파급 효과”의 최소화

➡️ 그래서 객체 지향 프로그래밍이란? 책임 및 역할을 분리하고 그 책임을 명확히 나누는 프로그래밍 방식
- 객체 : 역할/책임 → SOLID의 SRP 원칙이 떠오름
- 목표 : 응집도는 높고, 결합도는 낮게

### SRP (Single Responsibility Principle) - 단일 책임의 원리

하나의 클래스는 하나의 책임만 가진다.
- 알바생 B는 헹구기만 하고 퐁퐁은 하지 않는다.

### OCP (Open Closed Principle) - 개방 폐쇄의 원리
기능 추가에는 열려 있지만 수정에는 닫혀있어야 한다.

- 기능을 추가할 때 쉽게 추가하여 다른 코드를 변경하면서까지 코드 수정하지 않도록 구현
- 하나의 기능을 수정할 때 다른 클래스까지 수정해야 한다면 이는 OCP에 위배된 것
- 알바생

### LSP (Liskov Substitution Principle) - 리스코프 교체 원리

- 분류로써 하위 객체는 상위 객체로 교체될 수 있지만 상속 관계에서는 교체될 수 없다.
- 정사각형은 직사각형이다 (O), 아빠는 딸이다. (X)
    
    ```java
    Animal dog = new Dog();  //(o)
    Dog dog = new Dog();     //(o)
    Dog dog = new Animal();  //(x)
    ```
    

### ISP (Interface  Segregation Principle) - 인터페이스 격리 원리

- 클라이언트는 사용하지 않는 메서드에 의존하지 않도록 한다. → 사용하는 메서드만 가져온 인터페이스를 만들어서 클라이언트는 사용해야 됨
- 주방 알바생과 서빙 알바생이 있다고 할 때, 서빙 변경 사항만 있는데 알바생 둘다 부르는 건 비효율

### DIP (Dependency Inversion Principle) - 의존 관계 역전 원리

- 구체적인 것이 추상적인 것에 의존해야 한다. 추상적인 것이 구체적인 것에 의존하면 안 됨
- 사장이 설거지를 하는 경우는 거의 없고 알바생이 설거지 하고 사장에게 알바비를 받음

## 추상화 vs 캡슐화

### 추상화

- 정의 : 인터페이스나 추상 클래스와 같이 공통적인 구현을 하나로 묶는 것
- 구현(구체적) 클래스의 공통적인 부분을 클라이언트에서 접근하기 쉽게, 공통된 걸 묶어 인터페이스나 추상 클래스에 선언하는 것이 추상화의 근본
- 구현부가 뿌리, 줄기, 꽃 등이라면 인터페이스는 하나의 나무인 느낌?

### 캡슐화

- 정의 : 변수와 메서드를 묶고 변경 가능성이 높은 부분은 숨기는 것
- 속성과 메서드를 묶어서 클래스를 선언하는 것도 일종의 캡슐화
- 인터페이스를 통해 클라이언트에게 구현 부분이 아닌 사용할 수 있는 함수의 선언만 보이는 것
- 접근 제어자 private을 사용하는 것

→ 객체 지향의 특징으로써 비슷한 부분이 있지만 목적성에서 크게 다름

| 추상화 | 캡슐화 |
| --- | --- |
| 공통을 묶는 편의성 | 정보 은닉 |
| ISP | OCP |

---

# ✏️ Java에서 예외에 대해 서술하시오.

[참고 문서]

https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%97%90%EB%9F%ACError-%EC%99%80-%EC%98%88%EC%99%B8-%ED%81%B4%EB%9E%98%EC%8A%A4Exception-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%ACException-%EB%AC%B8%EB%B2%95-%EC%9D%91%EC%9A%A9-%EC%A0%95%EB%A6%AC

### 예외 처리의 목적

- 예기치 못한 문제에 미리 대응함으로써 프로그램 실행 중단을 막기 위함

### 예외 처리의 의미

- 프로그램 실행 중 발생할 수 있는 예상치 못한 문제를 미리 방지하는 코드를 작성하는 것
- 예외 : 프로그램 실행 중에 발생해 정상적인 명령 흐름을 방해하는 이벤트
- `try-catch-finally`
    - `try` : 예외가 발생할 수 있는 코드 블록 실행
    - `catch` : 예외가 발생한 코드 블록을 식별하여 원하는 종류의 예외를 처리
    - `finally` : 예외가 발생함에도 실행해야 하거나 해당 예외를 정리하는 코드 블록 수행
- `throws`

### 오류와 예외의 차이점

- 오류 (Error)
    1. 컴파일 에러 : 문법에 잘못된 게 있어 프로그램이 컴파일되지 않는 오류
    2. 런타임 에러 : 프로그램 실행 중 오류가 있거나 기계 결함과 같은 외부적 요인으로 인해 중단되는 오류
        - `StackOverflowError`, `OutOfMemoryError`, 등
    3. 논리 오류 : 버그, 실행에는 문제가 없지만 예상한 결과와 다르게 흘러가는 오류
    - JVM 실행에서 생긴 문제로 개발자의 대처가 쉽지 않음
- 예외 (Exception)
    - 정의 : 런타임 에러에서 발생하는 오류 중 코드로 대응이 가능한 오류나 컴파일 중 발생할 수 있는 심각하지 않은 문제 상황
    - 논리 오류나 사용자의 영향으로 발생
    - `IOException`, `RuntimeException`, 등
- **결론 → 개발자의 대처가 가능하냐 아니냐로 구분**

### 확인된 예외와 확인되지 않은 예외의 차이점

- 확인된 예외
    - 정의 : 컴파일 시점에 확인하는 예외로 처리하지 않으면 컴파일되지 않는 예외
- 확인되지 않은 예외
    - 정의 : 꼭 처리하지 않아도 실행되는 예외

[오류 종류 확인 자료] https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html

[예외 종류 확인 자료] https://docs.oracle.com/javase/8/docs/api/java/lang/Exception.html

---

# ✏️ 자바의 클래스 인스턴스 변수 초기화 순서에 대해서 설명하라.

### static vs final vs static final

- static - 공유
    - 객체 생성과 상관 없이 사용하고자 할 때 → 공유 개념
    - 모든 객체에 대해서 고정된 값, 불변은 아님
- final - 불변
    - 최종적인 값
    - 아예 불변
    - 객체에 따라 다른 값을 가질 수 있음 (공유, 공통 X)
    - 객체 생성 시간에 따라 생성되는 변수
- static final - 공유 + 불변
    - 전역에서 고정된 값으로 사용
    - 전역 변수, 상수 개념

### 초기화 순서

[참고 자료] https://7357.tistory.com/69

- 클래스 변수 (선)
    - 기본값 → 명시적 초기화 → 클래스 초기화 블럭
    - 클래스가 처음 로드될 때 한 번만 수행
    - 클래스 변수 : 클래스 내의 static 변수
- 인스턴스 변수 (후)
    - 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자
    - 객체가 생성될 때마다 수행
- 최종 순서
    1. `static int a = 1;` : a의 기본값은 0
    2. `static int a = 1;` : 명시적 초기화로 1
    3. `static { a = 2; }` : 클래스 초기화 블럭으로 2
    4. `int b = 1;` : b의 기본값은 0
    5. `int b = 1;` : b의 명시적 초기화로 1
    6. `{ b = 2; }` : 초기화 블럭으로 2
    7. `Class() { b = 3; }` : 생성자로 3

---

# 👀 느낀점

주말이니 간단하게 쓰자면 생각보다 빨리 끝났음 정신 없는 하루도 아니었고 OOP 간만에 다시 보는 내용이라 재밌었다. 사실 LSP, DIP 잘 이해 못 하고 있었는데 비유 방법 계속 생각하면서 이해가 수월해진 듯?

그리고 저 초기화 순서 정처기 공부할 때 대충 이해 하나도 안 하고 걍 코드 돌아가는 게 거기서 거기겠지 하고 넘어갔는데 순서가 명확하게 있어서 알아야 하는 부분이구나 싶은,, 사실 아예 이런 게 존재할 거라고 생각지도 못한 개념이다. 왜 이리 대충 하고 넘어간 개념이 많은지 새삼 많이 보이는 것에 반성...
